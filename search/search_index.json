{"config":{"lang":["en"],"separator":"[\\s\\-\\.\\_]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PyETR","text":"<p>Welcome to the PyETR documentation!</p> <p>PyETR (we like to pronounce it like \"Peter\") is a Python implementation of the Erotetic Theory of Reasoning (ETR) as presented in the book Reason &amp; Inquiry, OUP 2023.</p> <p>From the publisher:</p> <p> </p> <p>Reason and Inquiry: The Erotetic Theory presents a unified theory of the human capacity for reasoning and decision-making. The erotetic theory accounts for a diverse range of empirically documented fallacies and framing effects. It shows how the same mental processes that yield fallacies can yield what logicians call first-order validity and probabilistic coherence in reasoning, as well as rational decision-making as conceived by economists.</p> <p>The book's central idea is that our minds naturally aim at resolving issues, and if we are sufficiently inquisitive in the process, we can avoid mistakes. The erotetic theory holds that both the successes and the failures of reason are due to this aim. Rationality is secured if we reach what is described by the theory as erotetic equilibrium.</p> <p>Note for readers of Reason and Inquiry</p> <p>Anywhere you see a box like this one will be a reference to the book Reason &amp; Inquiry.</p> <p>For very short discussion of the erotetic theory see Koralus and Wang-Ma\u015bcianica 2023. The earliest version of a fragment of the erotetic theory of reason (not fully equivalent to the present version) goes back to Koralus and Mascarenhas 2013. </p> <p>Most users can dive straight in here for the overview of the book and code. This documentation focuses features of the python package and does not attempt to provide a standalone motivation or explanation of the erotetic theory, which is a book length endeavour. Book readers who may wish to understand how it relates to the code should instead begin here, before returning to the overview in \"Getting Started\".\"</p> <p>The documentation is structured as follows.</p> <ul> <li> <p>Getting started contains instructions for Installation and running Python.</p> </li> <li> <p>Usage explains in detail how to get started with the package, how to construct views, and provides examples.</p> </li> <li> <p>Advanced Usage looks \"under the hood\" and at some more advanced view construction.</p> </li> <li> <p>Theory recaps the ideas from Reason &amp; Inquiry that are important for PyETR. Users who are also readers of the book should also read this for some important information.</p> </li> <li> <p>Reference shows the available cases, operations and inference methods.</p> </li> <li> <p>Glossary describes terms used throughout the documentation.</p> </li> <li> <p>For Developers provides a summary of how to work on the package and produce new versions.</p> </li> <li> <p>Credits lists the people that worked on this project.</p> </li> </ul> <p>Info</p> <p>Top tip! If you're wondering what a term or operation means, or how it works, remember to use the search bar at the top - this often will show you to the right section!</p>"},{"location":"credits/","title":"Credits and Copyright","text":"<p>PyETR team</p> <p>Philipp Koralus (Project lead, University of Oxford)</p> <p>Sean Moss (Technical lead, University of Oxford and University of Birmingham)</p> <p>Mark Todd (Development lead, Dreaming Spires)</p> <p>Supported by generous grants from the Cosmos Institute, the Laces Trust, and the John Fell Oxford University Press Research Fund.</p> <p>We thank Vincent Wang-Ma\u015bcianica, Andrew Richardson, Ryan Kearns, and David Hyland for extensive testing, comments, and discussion.</p> <p>For use cases including reasoning under certainty, please cite:</p> <p>Koralus, P., Wang, V., Moss S., Mount, B. (2023). \u201cPredicate reasoning,\u201d in: Koralus, P. (2023). Reason and Inquiry: The Erotetic Theory, Oxford University Press.</p> <p>For use cases including reasoning under certainty, please cite: Koralus, P., Moss, S. (2023). \u201cReasoning with uncertainty,\u201d in: Koralus, P. (2023). Reason and Inquiry: The Erotetic Theory, Oxford University Press.</p> <p>For use cases including decision-making and practical reasoning, please cite:</p> <p>Koralus, P., Moss, S. (2023). \u201cDecision and practical reasoning,\u201d in: Koralus, P. (2023). Reason and Inquiry: The Erotetic Theory, Oxford University Press.</p> <p>MIT License</p> <p>Copyright (c) 2025 Philipp Koralus (University of Oxford), Sean Moss (University of Oxford and University of Birmingham), Mark Todd (Dreaming Spires)</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"development/","title":"Development (advanced)","text":"<p>If you wish to develop with the package, and make new releases, please find instructions for use below:</p>"},{"location":"development/#step-1-install-prerequisites","title":"Step 1: Install prerequisites","text":"<p>Make sure you first have installed. Note there are additional dependencies to simply running the package:</p> <ul> <li>Python 3.11 or later: https://python.org/downloads/</li> <li>Poetry https://python-poetry.org/docs/#installation</li> <li>Poetry bump version (installed with <code>poetry self add poetry-bumpversion</code>)</li> </ul>"},{"location":"development/#step-2-install-poetry-package","title":"Step 2: Install poetry package","text":"<p>Once you have the above, installing the package to develop with can be done with:</p> <pre><code>poetry install\n</code></pre>"},{"location":"development/#step-3-setup-pre-commit-hooks","title":"Step 3: Setup pre-commit hooks","text":"<p>To ensure code quality, per-commit hooks should be activated. This will automatically reformat new lines of code on commit. Install with</p> <pre><code>poetry run pre-commit install\n</code></pre>"},{"location":"development/#releasing-a-new-release","title":"Releasing a new release","text":""},{"location":"development/#step-1-changes-to-cases","title":"Step 1: Changes to cases","text":"<p>Any changes to the cases file will result in the <code>case_list.json</code> file needing to be updated. This file represents all of the views currently present in <code>cases.py</code> and <code>case_list_extra.json</code>, so needs to be kept in line with these. You can regenerate the file with: <pre><code>poetry run python generate_case_list.py\n</code></pre></p>"},{"location":"development/#step-2-check-the-tests","title":"Step 2: Check the tests","text":""},{"location":"development/#fast-mode-processes-in-around-10-seconds","title":"Fast Mode (processes in around 10 seconds)","text":"<p>You can run the tests in \"fast mode\". This is recommended as a good \"sanity check\" if you're working on developing a new feature (as it covers most use cases), but before making a full release it's recommended to run the full set of tests (see slow mode below).</p> <p>To run the fast tests, simply navigate to the tests folder and run:</p> <pre><code>poetry run pytest\n</code></pre>"},{"location":"development/#slow-mode-processes-in-around-55-seconds","title":"Slow Mode (processes in around 55 seconds)","text":"<p>Before making a release, it's worth checking the slow mode tests - these run all permutations of the cases view against each other, to search for any inconsistencies. It's also worth running these across multiple cores to increase the speed. This can be run with:</p> <pre><code>poetry run pytest --viewops -n &lt;number_of_cores&gt;\n</code></pre>"},{"location":"development/#step-3-bump-the-version","title":"Step 3: Bump the version","text":"<p>Finally bump the version with the below command, using either patch, minor or major:</p> <p><code>poetry version patch</code></p>"},{"location":"development/#step-4-commit-the-latest-version","title":"Step 4: Commit the latest version","text":"<p>Commit up the above changes to master branch.</p>"},{"location":"development/#step-5-build-the-package","title":"Step 5: Build the package","text":"<p>You then need to build the package with poetry using: <pre><code>poetry build\n</code></pre></p>"},{"location":"development/#step-6-make-the-release","title":"Step 6: Make the release","text":"<p>You can make a new release here</p> <p>Be sure to upload the <code>*.tar.gz</code> and <code>*.whl</code> files found in the ./dist directory.</p>"},{"location":"development/#testing","title":"Testing","text":"<p>For a test program, enter the tests directory and run:</p> <p><code>poetry run pytest -n auto</code></p> <p>For more advanced tests:</p> <p><code>poetry run pytest -n auto --viewops</code></p> <p>For coverage of pyetr (from tests folder):</p> <p><code>poetry run pytest -n 8 --viewops --cov=../pyetr/ --cov-report=term-missing</code></p>"},{"location":"glossary/","title":"Glossary of operations and terms","text":""},{"location":"glossary/#arbitrary-object","title":"Arbitrary Object","text":"<p>A kind of term. Analogous to 'bound variable' in logic. Comes in two kinds: 'universal arbitrary objects' are analogous to universally quantified variables, 'existential arbitrary objects' are analogous to existentially quantified variables.</p>"},{"location":"glossary/#arity","title":"Arity","text":"<p>The 'number' of arguments received by a function or predicate. In PyETR, this usually is a non-negative integer, but some terms such as Summation take a multiset of terms.</p>"},{"location":"glossary/#atom","title":"Atom","text":"<p>Atoms are the smallest units with logical content in PyETR, corresponding to positive and negative atomic formulae in logic. They are most often built out of predicates possibly applied to terms. See also do atoms which can contain atoms.</p>"},{"location":"glossary/#constant","title":"Constant","text":"<p>A 0-arity functional term.</p>"},{"location":"glossary/#default-reasoning-procedure","title":"Default Reasoning Procedure","text":"<p>The erotetic theory of reason holds that the primary aim of reason is to answer a question a reasoner has taken on board as directly as possible and arrive at a residual view that includes only what is \"novel\" after a judgment is made. The default reasoning procedure is an algorithmic empirical hypothesis about what the central tendency of the system is in terms of inferences being made, expressed in terms of operations like Update, Merge, Answer, and Factor.</p>"},{"location":"glossary/#dependency","title":"Dependency","text":"<p>Existential arbitrary objects can have a dependency on a number of universal arbitrary objects. If the existential \\(e\\) depends on universals \\(u_1,\\ldots,u_n\\), this can be read as \\(e\\) stands for a specific individual for every possible instantiation of \\(u_1,\\ldots,u_n\\).</p>"},{"location":"glossary/#dependency-relation","title":"Dependency Relation","text":"<p>Contains the classifications of arbitrary objects into universals and existentials, as well as any dependencies between arbitrary objects.</p>"},{"location":"glossary/#do-atom","title":"Do Atom","text":"<p>An atom formed by the keyword <code>do</code> applied to a set of atoms. A chain of reasoning that ends in a view such as <code>{ do(A B C) }</code> means making a decision to 'act so as to make <code>A</code>, <code>B</code>, and <code>C</code> the case'.</p>"},{"location":"glossary/#factor","title":"Factor","text":"<p>A view operation which reduces the complexity of the current view by factoring out the content of a second view. An important special case is to 'factor out falsum', which drops any states that contain a primitive absurdity.</p>"},{"location":"glossary/#functional-term","title":"Functional Term","text":"<p>A functional term represents a mathematical function. Can be a constant or contain other terms.</p>"},{"location":"glossary/#inquire","title":"Inquire","text":"<p>To pose a question on a starting view, where the question is represented as another view.</p>"},{"location":"glossary/#issue-context","title":"Issue Context","text":"<p>A structure representing the location of the issue or question mark in an atom.</p>"},{"location":"glossary/#issue-structure","title":"Issue Structure","text":"<p>The section of the view that describes which parts of the stage and supposition are at issue. Expressed as a series of pairs of term and issue contexts.</p>"},{"location":"glossary/#merge","title":"Merge","text":"<p>Combine two views.</p>"},{"location":"glossary/#multiset","title":"Multiset","text":"<p>A multiset is a collection of objects which is unordered and possibly has repeats, cf. Set In ETR multisets are represented as comma-separated lists between double-angle brackets, thus</p> \\[     \\llangle 1,1,2 \\rrangle = \\llangle 1,2,1 \\rrangle = \\llangle 2,1,1 \\rrangle \\] <p>are three ways of writing the same thing: the multiset containing two copies of the number \\(1\\) and one copy of the number \\(2\\).</p> <p>In ETR, multisets are always finite and can be empty.</p>"},{"location":"glossary/#novelization","title":"Novelization","text":"<p>Novelizing a set of arbitrary objects in a view (or state, etc) means selecting a replacement for each one, all distinct from any arbitrary object used up to that point, and systematically substituting the replacements for all occurrences of the originals.</p> <p>The resulting view is 'alpha-equivalent' to the original one, in the sense familiar from logic, type theory, and programming languages.</p>"},{"location":"glossary/#predicate","title":"Predicate","text":"<p>A logic predicate that receives a certain number of arguments.</p>"},{"location":"glossary/#real-number","title":"Real Number","text":"<p>A type of constant with an associated numeric value.</p>"},{"location":"glossary/#query","title":"Query","text":"<p>A view operation for determining whether a given conclusion is directly supported by the current view.</p>"},{"location":"glossary/#set","title":"Set","text":"<p>A set is a collection of objects which is unordered and without repeats, cf Multiset. As is standard, sets are represented as comma-separated lists between curly brackets, thus</p> \\[     \\{1,2\\} = \\{2,1\\} = \\{1,1,2\\} \\] <p>are three (of many possible) ways of writing the same thing: the set whose members are \\(1\\) and \\(2\\) only (note that repeating a member in the description has no effect). However, note that a State is by definition a kind of set, but when a set is considered as a state we use a different notation, see Stages and states and Do atoms in View construction.</p> <p>In PyETR, all sets are finite, so we usually write 'set' when we really mean 'finite set'. In ETR, all sets involved in the construction of a View are finite, but note that some entities, such as \"the set of all views\", are infinite sets.</p>"},{"location":"glossary/#stage","title":"Stage","text":"<p>The main component of a view is the stage. In general, the stage is a set of weighted states, but if all weights are trivial it will appear just as a set of states.</p> <p>Intuitively, the stage expresses a disjunction of the states it contains, with extra non-logical information in the weights.</p>"},{"location":"glossary/#state","title":"State","text":"<p>A state is a set of atoms and do-atoms. Intuitively, a state expresses a conjunction of the atoms it contains.</p>"},{"location":"glossary/#supposition","title":"Supposition","text":"<p>A set of weighted states representing a condition.</p>"},{"location":"glossary/#term","title":"Term","text":"<p>An arbitrary object or functional term.</p>"},{"location":"glossary/#update","title":"Update","text":"<p><code>update</code> is a view operation. It is the workhorse of reasoning, being a key component of the Default Reasoning Procedure. For an initial view <code>G</code> and an incoming view <code>D</code>, <code>G.update(D)</code> is a view which updates <code>G</code> by treating <code>D</code> as a source of new information that potentially resolves some of the inquisitiveness of <code>G</code>.</p> <p><code>update</code> actually decomposes into more basic operations. In PyETR, <code>G.update(D)</code> </p> <p>written \\(G[D]^\\circlearrowright\\) in R&amp;I and <code>G.update(D)</code> in PyETR.</p> <p>First View: Currently active point of view Second View: Treated as a fact Conclusion: New active point of view</p> <p>Take a starting view, and when provided a new perspective produces a third view.</p>"},{"location":"glossary/#view","title":"View","text":"<p>A view is the basic object manipulated during reasoning. The current focus of a reasoner is taken to be a view. Incoming information arrives as a sequence of views, and latent beliefs are a collection of views. The different view operations correspond to different ways of evolving the current view in light of either new information or selected latent beliefs.</p> <p>Views are built up from a Stage, a Supposition, a Dependency Relation, and an Issue Structure.</p>"},{"location":"glossary/#weight","title":"Weight","text":"<p>A weight is a multiset of terms designated as either the additive or multiplicative weight in a weighted state.</p>"},{"location":"glossary/#weighted-state","title":"Weighted state","text":"<p>Each state in a stage is equipped with extra non-logical content in the form of additive and multiplicative weights, making it a weighted state. States in suppositions do not come with weights. One or both of the weights can be empty. A weighted state where both weights are the empty multiset is notated just as an ordinary state.</p>"},{"location":"advanced_usage/defining_inference/","title":"Custom inference operations","text":"<p>PyETR comes packaged with several inference procedures, but in this tutorial we'll demonstrate how to make your own. We can use python functions combined with the methods it provides to construct new inference procedures.</p> <p>Let's suppose we have an operation that takes two views and does update, suppose, query:</p> <pre><code>from pyetr import View\n\ndef new_inference(v1: View, v2: View):\n    return v1.update(v2).suppose(v2).query(v2)\n</code></pre> <p>We can easily chain these operations together. To add verbose mode:</p> <pre><code>from pyetr import View\n\ndef new_inference(v1: View, v2: View, verbose: bool = False):\n    return v1.update(v2, verbose=verbose).suppose(v2, verbose=verbose).query(v2, verbose=verbose)\n</code></pre> <p>Now each operation follows the verbosity of the input boolean.</p>"},{"location":"advanced_usage/defining_inference/#a-more-complex-case","title":"A more complex case","text":"<p>Suppose we have a slightly more complex operation, where the first view in a tuple is to be updated and supposed by each following view:</p> <p>Here, again we can use the python language feature of for loops to iteratively apply these operations:</p> <pre><code>from pyetr import View\n\ndef complex_inference(views: list[View]):\n    new_view = views[0]\n    if len(views) == 1:\n        return new_view\n    for v in views[1:]:\n        new_view = new_view.update(v).suppose(v)\n    return new_view\n\nv0 = View.from_str(\"{X()}\")\nv1 = View.from_str(\"{Y()}\")\nv2 = View.from_str(\"{Z()}\")\nv3 = complex_inference([v0,v1,v2])\nprint(v3.to_str()) # {X()Z()Y()}^{Z()Y()}\n</code></pre> <p>Python has the flexibility to express any combination of operations as desired, but hopefully this gives a good basis to begin learning more advanced language features.</p>"},{"location":"advanced_usage/func_callers/","title":"Custom Function Behaviour","text":"<p>As discussed here it's possible in PyETR to define and use numerical functions that combine real number terms in a variety of ways. In this section we'll discuss an advanced variant of this, wherein users may define their own custom functions.</p>"},{"location":"advanced_usage/func_callers/#a-3-argument-function","title":"A 3 Argument Function","text":"<p>Below is a demonstration of a simple custom function, applied to three numeric arguments: <pre><code>from pyetr import View\n\ndef someOp(x: float, y: float, z: float) -&gt; float:\n    return (x * y) // z\n\nv1 = View.from_str(\"{A(someOp(3,4,5))}\", custom_functions=[someOp])\nprint(v1) # {A(2.0)}\n</code></pre> Here we see the above operation has been applied to the terms given.</p>"},{"location":"advanced_usage/func_callers/#when-resolution-occurs","title":"When resolution occurs","text":"<p>If an operation leads to a substitution of one term for a numeric term, this will also lead to a numeric calculation. In the below example, we see how the arbitrary object <code>x</code> in <code>v2</code> in replaced by the <code>5</code> from <code>v1</code>, and this in turn causes the function to be calculated:</p> <pre><code>from pyetr import View\nfrom pyetr.inference import default_inference_procedure\n\ndef someOp(x: float, y: float, z: float) -&gt; float:\n    return (x * y) // z\n\nv1 = View.from_str(\"{A(5*)}\", custom_functions=[someOp])\nv2 = View.from_str(\"\u2200x {B(someOp(3,4,x))}^{A(x*)}\", custom_functions=[someOp])\n\nprint(v1) # {A(5.0*)}\nprint(v2) # \u2200x {B(someOp(3.0,4.0,x))}^{A(x*)}\nprint(default_inference_procedure((v1,v2))) # {B(2.0)}\n</code></pre>"},{"location":"advanced_usage/func_callers/#multiset-functions","title":"Multiset functions","text":"<p>You may have noticed that one of the predefined functions, Summation, does not in fact receive a fixed number of arguments as I have described above. This is because there exists another type of function, that receives a Multiset of items instead of a fixed arity tuple.</p> <p>To do this, we must use the \"Var Positional\" or <code>*args</code> kind of function argument. In the below example we create the operation \"product\", that as with Summation receives an unlimited number of arguments:</p> <pre><code>from pyetr import View\nfrom pyetr.inference import default_inference_procedure\n\ndef product(*x: float) -&gt; float:\n    v: float = 1\n    for i in x:\n        v *= i\n    return v\n\nv1 = View.from_str(\"{A(5*)}\", custom_functions=[product])\nv2 = View.from_str(\"\u2200x {B(product(3,4,x))}^{A(x*)}\", custom_functions=[product])\nprint(v1) # {A(5.0*)}\nprint(v2) # \u2200x {B(product(3.0,4.0,x))}^{A(x*)}\nprint(default_inference_procedure((v1,v2))) # {B(60.0)}\n</code></pre>"},{"location":"advanced_usage/func_callers/#alternative-syntax-name-overrides","title":"Alternative Syntax &amp; Name Overrides","text":"<p>The above syntax assumes that the name of the function matches the name used in the string. It's possible that you may wish to use a different name in the view string, than in the function itself. For this we present an alternative syntax, that creates the Function class more directly. In the below example, the function name contains an underscore (a disallowed character in the view string), and the desired name of the function in the view string is also quite short:</p> <pre><code>from pyetr import View, Function\n\ndef some_op(x: float, y: float, z: float) -&gt; float:\n    return (x * y) // z\n\nv1 = View.from_str(\"{A(f(3,4,5))}\", custom_functions=[Function.numeric(some_op, name_override='f')])\nprint(v1) # {A(2.0)}\n</code></pre>"},{"location":"advanced_usage/func_callers/#overlapping-names-danger","title":"Overlapping Names (Danger!)","text":"<p>This section is more of a health hazard - the custom function syntax allows for many input types, and where possible we've tried to add errors where inconsistent usage occurs, but it occurred to me there are still some things to be aware of.</p> <p>Consider the below example:</p> <pre><code>from pyetr import View, Function\n\ndef some_op(x: float, y: float, z: float) -&gt; float:\n    return (x * y) // z\n\nv1 = View.from_str(\"\u2200x {A(f(3,4,x))}\", custom_functions=[Function.numeric(some_op, name_override='f')])\nprint(v1) # \u2200x {A(f(3.0,4.0,x))}\n\ndef some_new_op(x: float, y: float) -&gt; float:\n    return x * y\n\nv2 = View.from_str(\"\u2200x {A(f(3,x))}\", custom_functions=[Function.numeric(some_new_op, name_override='f')])\nprint(v2) # \u2200x {A(f(3.0,x))\n</code></pre> <p>So far so good right? We have two independent views that aren't interacting with different arity functions.</p> <p>Danger</p> <p>Do not do this. It's not funny and it's not clever.</p> <p>As far as the package is concerned it will accept this as the two definitions are mutually exclusive, but this is not recommended as it's extremely confusing readability wise, particularly if these views are later combined: <pre><code>print(v1.update(v2)) # \u2200x \u2200a {A(f(3.0,a))A(f(3.0,4.0,x))}\n</code></pre></p>"},{"location":"advanced_usage/func_callers/#well-but-they-arent-exactly-overlapping-definitions-right","title":"Well, but they aren't exactly overlapping definitions right?","text":"<p>Sure, in the above case the definitions don't overlap as the functions have different arities. However, if we instead consider a case where they have the same arity:</p> <pre><code>from pyetr import View, Function\n\ndef some_op(x: float, y: float) -&gt; float:\n    return x * y\n\nv1 = View.from_str(\"\u2200x {A(f(3,x))}\", custom_functions=[Function.numeric(some_op, name_override='f')])\nprint(v1) # \u2200x {A(f(3.0,4.0,x))}\n\ndef some_new_op(x: float, y: float) -&gt; float:\n    return x // y\n\nv2 = View.from_str(\"\u2200x {A(f(3,x))}\", custom_functions=[Function.numeric(some_new_op, name_override='f')])\nprint(v2) # \u2200x {A(f(3.0,x))\n</code></pre> <p>And now if we combine the two: <pre><code>print(v1.update(v2)) # \u2200x \u2200a {A(f(3.0,x))A(f(3.0,a))}\n</code></pre> We now have no idea which f corresponds to which function - simply put in general it's really worth using different names.</p> <p>Info</p> <p>These kind of overlaps can also cause issues if one definition of the function uses a multiset function.</p>"},{"location":"advanced_usage/overview/","title":"Advanced Usage","text":"<p>If you're reading this, you should probably have read and feel you have a good understanding of the Getting Started and Usage sections. We're about to take a look \"under the hood\" of PyETR, looking at topics such as:</p> <ul> <li> <p>How to define your own inference operations and numeric functions</p> </li> <li> <p>How to inspect the constituent operations that make up larger operations like Update</p> </li> <li> <p>What equality means in PyETR, and how it may differ from what you would have expected.</p> </li> </ul>"},{"location":"advanced_usage/troubleshooting/","title":"Troubleshooting with verbose mode","text":"<p>It may be that the output of the program doesn't produce what you expected. If this is the case, there is a feature that might be useful to you. You can inspect the internal operations that occur during another operation.</p> <p>Let's take for example an update and factor operation:</p> <pre><code>from pyetr import View\n\nv1 = View.from_str(\"{~Q(q())~P(p()), 0}^{~Q(q())}\")\n\nv2 = View.from_str(\"{P(p())}\")\n\nv3 = v1.update(v2) # {P(p()),P(p())~P(p())~Q(q())}^{~Q(q())}\nprint(v3.to_str())\n\nfalsum = View.from_str(\"{}\")\nv4 = v3.factor(falsum) # {P(p())}^{~Q(q())}\nprint(v4.to_str())\n</code></pre> <p>But suppose I wanted to know what was happening in side the update operation, I could enable verbose mode:</p> <p><pre><code>from pyetr import View\n\nv1 = View.from_str(\"{~Q(q())~P(p()), 0}^{~Q(q())}\")\n\nv2 = View.from_str(\"{P(p())}\")\n\nv3 = v1.update(v2, verbose=True)\n</code></pre> ...and the output shows:</p> <pre><code>UpdateInput: External: {~P(p)~Q(q),0}^{~Q(q)} Internal {P(p)}^{0}\nUniProdInput: External: {~P(p)~Q(q),0}^{~Q(q)} Internal {P(p)}^{0}\nUniProdOutput: {~P(p)~Q(q),0}^{~Q(q)}\nExiSumInput: External: {~P(p)~Q(q),0}^{~Q(q)} Internal {P(p)}^{0}\nExiSumOutput: {~P(p)~Q(q),0}^{~Q(q)}\nAnswerInput: External: {~P(p)~Q(q),0}^{~Q(q)} Internal {P(p)}^{0}\nEquilibriumAnswerInput: External: {~P(p)~Q(q),0}^{~Q(q)} Internal {P(p)}^{0}\nPotentials: [(0, ~P(p)~Q(q)), (0, 0)]\nEquilibriumAnswerOutput: {~P(p)~Q(q),0}^{~Q(q)}\nAtomicAnswerInput: External: {~P(p)~Q(q),0}^{~Q(q)} Internal {P(p)}^{0}\nAtomicAnswerOutput: {~P(p)~Q(q),0}^{~Q(q)}\nAnswerOutput: {~P(p)~Q(q),0}^{~Q(q)}\nMergeInput: External: {~P(p)~Q(q),0}^{~Q(q)} Internal {P(p)}^{0}\nMergeOutput: {~P(p)~Q(q)P(p),P(p)}^{~Q(q)}\nUpdateOutput: {~P(p)~Q(q)P(p),P(p)}^{~Q(q)}\n</code></pre> <p>Here we see that the only operation that actually affecting the output is the \"merge\" operation. This shows that we can both learn more about the internal operations using this, and also see which step is behaving unusually for troubleshooting.</p>"},{"location":"advanced_usage/view_equality_and_equivalence/","title":"View Equality and Equivalence (advanced)","text":"<p>This might be considered something of an advanced topic, as it concerns the exact conditions we consider views to equal or equivalent. To understand this, you should be familiar with the theoretical definition of views.</p>"},{"location":"advanced_usage/view_equality_and_equivalence/#a-note-for-python-programmers","title":"A note for python programmers","text":"<p>If you're quite familiar with Python, you may be quite surprised to find two separate View instances are equal to each other. This isn't a mistake - it's by design. We wanted to ensure that no matter where a view is instantiated, the resulting object is not necessarily unique. Take a quick example:</p> <pre><code>class X:\n    pass\n\nx1 = X()\nx2 = X()\nprint(x1 == x2) # Returns False\n</code></pre> <p>As expected, these two separate instances are not equal. But if we take two views:</p> <pre><code>from pyetr import View\n\nv1 = View.from_str(\"{}\")\nv2 = View.from_str(\"{}\")\n\nprint(v1 == v2) # Returns True\n</code></pre> <p>This is because in the PyETR package we say that two object are equal if that represent exactly the same object, no matter where they were instantiated.</p>"},{"location":"advanced_usage/view_equality_and_equivalence/#when-are-views-equal","title":"When are views equal","text":"<p>The considerations for if two views are equal are quite simple. Broadly speaking, if the book would  view two views strings as identical, so will python equality. Notably this does not allow for different naming schemes etc - for two views to be equal they much express the same concept using the same notation. E.g.</p> <pre><code>v1 = View.from_str(\"{A(f())B(f())}\")\nv2 = View.from_str(\"{B(f())A(f())}\")\n\nprint(v1 == v2) # Returns True\n</code></pre> <p>Since the A and B atoms share the same state, the fact here they are in a different order in v1 vs v2 is irrelevant. Both these strings represent the exact same view. However if instead we try:</p> <pre><code>v1 = View.from_str(\"{A(f(), g())}\")\nv2 = View.from_str(\"{A(g(), f())}\")\n\nprint(v1 == v2) # Returns False\n</code></pre> <p>Since ordering matters inside the atom, these two views are not equal to one another. Wherever a set is used (e.g. States, Stage, Supposition, DoAtoms) ordering is irrelevant, but anywhere a tuple or ordered object is used ordering matters to the equality of two views.</p>"},{"location":"advanced_usage/view_equality_and_equivalence/#when-are-views-are-equivalent-under-substitution","title":"When are views are equivalent under substitution","text":"<p>The letters used to describe arbitrary objects are in some sense - arbitrary. We've therefore made a bespoke check for, if we were to ignore the different naming conventions of the arbitrary objects, would two views be equal. See the example below:</p> <pre><code>v1 = View.from_str(\"\u2200x {A(x)}\")\nv2 = View.from_str(\"\u2200y {A(y)}\")\n\nprint(v1 == v2) # Returns False\nprint(v1.is_equivalent_under_arb_sub(v2)) # Returns True\n</code></pre> <p>Limit of Equivalence Check</p> <p>Due to the fact the comparison must check all permutations for a series of arbitrary objects, there is a certain computation limit. The computational complexity is O((n!)^2*n) where n is average num of existentials and universals, so as you can imagine for a feasible number of arbitrary objects this become impractical. We've set the limit at 9 of each type in each view, which seems to process in a reasonable computation time. Anything higher than this is unlikely to appear in real world scenarios.</p>"},{"location":"getting_started/installation/","title":"Installation","text":""},{"location":"getting_started/installation/#step-1-install-prerequisites","title":"Step 1: Install prerequisites","text":"<p>Make sure you first have installed:</p> <ul> <li>Python 3.11 or later: https://python.org/downloads/</li> </ul>"},{"location":"getting_started/installation/#step-2-install-the-package","title":"Step 2: Install the package","text":"<p>You can install the package with the following command: <pre><code>pip install pyetr\n</code></pre></p>"},{"location":"getting_started/overview/","title":"Overview","text":"<p>On this page we summarize the main points of the Erotetic Theory of Reasoning (ETR) as implemented in PyETR.</p>"},{"location":"getting_started/overview/#views","title":"Views","text":"<p>ETR is centred around the manipulation of objects called views. Views are what a reasoner works with: the current focus of attention is a view, incoming information arrives packaged as a view or sequence of views, and latent beliefs are a collection of views.</p> <p>Every view has an underlying truth-conditional content, equivalent to some sentence of first-order logic. However, a view is more than this, because logically equivalent but distinct views are treated differently in the reasoning procedure hypothesized in ETR. The extra content can be seen as 'inquisitiveness' about certain topics.</p> <p>The central hypothesis of ETR is that the goal of reasoning is to resolve inquisitiveness. Moreover, it is hypothesized that failures of reasoning, relative to formal standards of rationality, arise from this tendency and that failure can be averted by explicitly enforcing a certain amount of inquisitiveness.</p>"},{"location":"getting_started/overview/#looking-at-a-view","title":"Looking at a view","text":"<p>For concreteness, let us study a view from Example 56. Once you have set up PyETR you can inspect the provided examples as follows. <pre><code>from pyetr.cases import e56_default_inference\n\nv = e56_default_inference.v[1]\nprint(v) # \u2200z \u2203w {Student(z*)Reads(z,w)Book(w)}^{Student(z*)}\n</code></pre> Lines beginning <code>&gt;&gt;&gt;</code> are user input and other lines are Python output. Here we have imported one of the views from Example 56 of R&amp;I and given it the name <code>v</code>. Then asking Python for <code>v</code> causes a string representation of <code>v</code> to be printed.</p> <p>Warning</p> <p>There are several formats that can be used for 'printing' views in PyETR. The default one is chosen for convenience of reading and writing, rather than a perfect match to the notation used in R&amp;I.</p> <p>Info</p> <p>Instead of importing the example, you could copy and paste any string given as an output like this <pre><code>from pyetr import View\n\nv = View.from_str(\"\u2200z \u2203w {Student(z*)Reads(z,w)Book(w)}^{Student(z*)}\")\nprint(v) # \u2200z \u2203w {Student(z*)Reads(z,w)Book(w)}^{Student(z*)}\n</code></pre></p> <p>Asking Python to print <code>v</code> is equivalent to the following <pre><code>print(v.to_str()) # \u2200z \u2203w {Student(z*)Reads(z,w)Book(w)}^{Student(z*)}\n</code></pre> Aside from <code>to_str()</code>, another way to render a view is <code>base</code>. <pre><code>print(v.base) # {Student(z)Reads(z,w)Book(w)}^{Student(z)} issues={(z,Student(?))} U={z} E={w} deps=z{w}\n</code></pre> This is provided to give a close match to the notation and theoretical structure of views provided in R&amp;I. It should not be necessary to use <code>base</code> to follow calculations, as all relevant information is encoded in the <code>to_str()</code> representation, but it may be helpful for learning to connect the concrete <code>to_str()</code> syntax with the abstract structures of R&amp;I.</p>"},{"location":"getting_started/overview/#anatomy-of-a-view","title":"Anatomy of a view","text":"<p>A view consists of four main parts.</p> <ul> <li>Stage</li> <li>Supposition</li> <li>Dependency Relation</li> <li>Issue Structure</li> </ul> <p>Let's see how these appear in the Python printout for our running example.</p> <p>In <code>v.to_str()</code>, the stage and the supposition appear with the issue structure mixed in as <pre><code>{Student(z*)Reads(z,w)Book(w)}^{Student(z*)}\n</code></pre> where the <code>^</code> separates the stage on the left from the supposition on the right. (In R&amp;I, the supposition is written as a superscript). Despite what the notation would suggest, the asterisks encode the issue structure which is a separate section of the view from the stage or supposition. This is made more clear with <code>v.base</code> where <pre><code>{Student(z)Reads(z,w)Book(w)}^{Student(z)} issues={(z,Student(?))}\n</code></pre> shows the stage and supposition in the same format but without asterisks, and the issue structure given separately. The issue structure tells us that <code>z</code> is at issue for being a <code>Student</code>.</p> <p>Info</p> <p>For this view, the issue structure contains only a single item, which is clear from <code>v.base</code> but less so from <code>v.to_str()</code>. This is because issues are not local to particular positions in the stage or supposition, but apply globally to a view. We will discuss this further in View construction. This is one advantage to the more verbose <code>base</code> representation.</p> <p>Finally, in <code>v.to_str()</code> the dependency relation is determined by the prefix <pre><code>\u2200z \u2203w\n</code></pre> while for <code>v.base</code> it is determined by the suffix: <pre><code>U={z} E={w} deps=z{w}\n</code></pre></p> <p>The <code>v.base</code> form tells us explicitly that the view contains the arbitrary objects <code>z</code> and <code>w</code>, with <code>z</code> being universal and <code>w</code> being existential. In ETR, existential objects can depend on universals, and so the <code>deps</code> part tells us that the set of existentials depending on <code>z</code> is just the set <code>w</code>, i.e. that the only dependency is that of <code>w</code> on <code>z</code>.</p> <p>The <code>to_str()</code> representation contains the same information in a condensed form. We can see the \u2200 (for all) and \u2203 (there exists) quantifier symbols attached to each arbitrary object tell us whether they are universal or existential respectively. The dependencies are encoded in the order that the variables are listed: because the existential <code>w</code> is to the right of the universal <code>z</code>, <code>w</code> must depend on <code>z</code>.</p> <p>Info</p> <p>The dependency relations of ETR are in one-to-one correspondence with strings of first-order quantifiers up to reordering of similar quantifiers. This justifies the use of the quantifier string as a convenient notation for dependency relations. The key caveat is that in a chain of quantifiers of the same type, e.g. <code>\u2203a \u2203b \u2203c</code>, there is no significance at all to the ordering of <code>a</code>, <code>b</code>, and <code>c</code>: effectively an order is just chosen arbitrarily in order to print out a string. Another way to say this is that in first-order logic, permuting such strings of quantifiers preserves logical equivalence, but in ETR it actually preserves the equality class of the view.</p>"},{"location":"getting_started/overview/#states-and-weights","title":"States and weights","text":"<p>In the example above, the stage appeared as sequence of three 'atoms': <code>Student(z)</code>, <code>Reads(z,w)</code>, <code>Book(w)</code>. Intuitively, this is a conjunction ('and') of the three atomic propositions. Really, a stage is a comma-separated set of states, each of which is a set of atoms. Each state is intuitively a conjunction of its constituent atoms, and the stage is intuitively a disjunction ('or') of its constituent states. The order of atoms within a state, and the order of states within the stage, have no significance. Furthermore, each state in the stage can carry an optional 'multiplicative' weight and/or 'additive weight'.</p> <p>Let us consider another example from Example 69. <pre><code>from pyetr.cases import e69_part1\n\nv2 = e69_part1.v[1]\nprint(v2) # {0.000001=* ~Guilty(Suspect())Match(Suspect()),~Guilty(Suspect())~Match(Suspect())}^{~Guilty(Suspect())}\n</code></pre> Here the stage consists of two states (because there is one comma). Each state consists of two atoms, but the first (in the arbitrary printed order) state has a multiplicative weight of <code>0.000001</code>, as indicated by the <code>0.000001=*</code> prefix.</p> <p>The supposition of a view is also set of states, but states in a supposition do not carry weights. Most commonly, the supposition consists of a single empty state, in which case we omit the supposition in notation. Next most typically the supposition is a single state with a single atom, occasionally it is a single state with more than one atom, and only very rarely will it have a different number of states.</p>"},{"location":"getting_started/overview/#operations-and-inference-procedures","title":"Operations and inference procedures","text":"<p>Once we have a view, reasoning consists in changes to that view, possibly in light of new information. In ETR, changes to the current view are effected by a basic set of operations, each of which acts on the current view in light of a second view. The second view is sometimes either new or recalled information, though often it does not stand for its logical content.</p> <p>View operations can be referenced in their own index. As an example, perhaps the most useful operation is update, used as follows. <pre><code>from pyetr import View\n\nv1 = View.from_str(\"{Man(Socrates()*)}\")\nv2 = View.from_str(\"Ax {Mortal(x)}^{Man(x*)}\")\nv1.update(v2) # {Mortal(Socrates())Man(Socrates()*)}\n</code></pre></p> <p>In ETR, the capacity for reasoning is constrained by the limited set of view operations, and the process of reasoning consists in following procedures that chain together these basic operations rather than apply single basic operations. A few built-in inference procedures are listed in an index. For example, the default inference procedure for \"what if anything follows?\" questions can be used as follows. <pre><code>from pyetr import View\nfrom pyetr.inference import default_inference_procedure\n\nv1 = View.from_str(\"{Man(Socrates()*)}\")\nv2 = View.from_str(\"Ax {Mortal(x)}^{Man(x*)}\")\nprint(default_inference_procedure([v1,v2])) # {Mortal(Socrates())}\n</code></pre> The <code>default_inference_procedure</code> internally uses the <code>update</code> operation, but chains it with other operations to produce a conclusion with only novel contents.</p>"},{"location":"getting_started/python/","title":"Getting started with python","text":"<p>For users unfamiliar with Python, there do exist many guides online including this from the developers of Python. However, as a quick intro we'll show how to get started in a couple of basic ways:</p>"},{"location":"getting_started/python/#running-an-interactive-shell","title":"Running an interactive shell","text":"<p>Let's assume you've already installed the package and Python. To initiate an interactive shell, you'll need to first open a terminal. Next simply type:</p> <p><pre><code>python\n</code></pre> Depending on your exact installation you may need to instead type <code>python3</code> or perhaps even <code>python3.11</code> or <code>python3.12</code>, but for the purposes of this tutorial we'll assume the above.</p> <p>This opens a shell like so:</p> <p><pre><code>&gt;&gt;&gt;\n</code></pre> You can try something simple like:</p> <pre><code>&gt;&gt;&gt; print(\"Hello world!\")\n</code></pre> <p>Or even:</p> <p><pre><code>&gt;&gt;&gt; from pyetr import View\n</code></pre> To test that pyetr has installed correctly. This has full flexibility to allow you can type commands and test features, but a lot of the time you'll find it easier to work inside a script.</p>"},{"location":"getting_started/python/#running-a-script","title":"Running a script","text":"<p>First make a file somewhere in your OS:</p> <pre><code>test.py\n</code></pre> <p>Inside this file, place whatever commands you desire, like:</p> <pre><code>print(\"Hello world!\")\n</code></pre> <p>To run the script now just use:</p> <p><pre><code>python test.py\n</code></pre> (Assuming you're in the same directory as the file)</p> <p>That's really all there is to it! However, it may be that you might want some more advanced controls over your files. For this I would recommend using the IDE VS Code.</p>"},{"location":"getting_started/python/#setting-up-an-ide","title":"Setting up an IDE","text":"<p>First you need to download VSCode. This can be done here.</p> <p>Next, open a folder you wish to use for development. </p> <p>Make a new file with <code>File -&gt; New File</code>, and title this <code>test.py</code>.</p> <p>Now open a terminal with <code>Terminal -&gt; New Terminal</code>, and run the script as shown above. Running inside the IDE allows you to add extensions for spellcheck and type completion (I recommend installing Pylance). This will accelerate your development.</p>"},{"location":"reference/case_index/","title":"Case Index","text":"<p>Below you'll find all of the cases in pyetr.cases, and their associated views. You can use this page as an index of the current cases.</p>"},{"location":"reference/case_index/#e1","title":"e1","text":"<p>Link to code</p> <pre><code>description:\nExample 1, p61:\n\nP1 Either Jane is kneeling by the fire and she is looking at the TV or else\nMark is standing at the window and he is peering into the garden.\nP2 Jane is kneeling by the fire.\nC Jane is looking at the TV.\nv[0]: {KneelingByTheFire(Jane())LookingAtTV(Jane()),PeeringIntoTheGarden(Mark())StandingAtTheWindow(Mark())}\nv[1]: {KneelingByTheFire(Jane())}\n\nc (Conclusion): {LookingAtTV(Jane())}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e2","title":"e2","text":"<p>Link to code</p> <pre><code>description:\nExample 2, p62:\n\nP1 There is at least an ace and a queen, or else at least a king and a ten.\nP2 There is a king.\nC There is a ten.\nv[0]: {A()Q(),K()T()}\nv[1]: {K()}\n\nc (Conclusion): {T()}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e3","title":"e3","text":"<p>Link to code</p> <pre><code>description:\nExample 3, p63:\n\nP1 There is at least an ace and a king or else there is at least a queen and\na jack.\nP2 There isn't an ace.\nC There is a queen and a jack.\nv[0]: {Ace()King(),Jack()Queen()}\nv[1]: {~Ace()}\n\nc (Conclusion): {Jack()Queen()}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e5ii","title":"e5ii","text":"<p>Link to code</p> <pre><code>description:\nExample 5, p72, part ii\nv[0]: {p1()q1(),r1()s1()}\nv[1]: {p2()q2(),r2()s2()}\n\nc (Conclusion): {p1()p2()q1()q2(),p1()q1()r2()s2(),p2()q2()r1()s1(),r1()r2()s1()s2()}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e5iii","title":"e5iii","text":"<p>Link to code</p> <pre><code>description:\nExample 5, p72, part iii\nv[0]: {p1()q1(),r1()s1()}\nv[1]: {}\n\nc (Conclusion): {}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e5iv","title":"e5iv","text":"<p>Link to code</p> <pre><code>description:\nExample 5, p72, part iv\nv[0]: {p1()q1(),r1()s1()}\nv[1]: {0}\n\nc (Conclusion): {p1()q1(),r1()s1()}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e5v","title":"e5v","text":"<p>Link to code</p> <pre><code>description:\nExample 5, p72, part v\nv[0]: {0}\nv[1]: {p1()q1(),r1()s1()}\n\nc (Conclusion): {p1()q1(),r1()s1()}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e6","title":"e6","text":"<p>Link to code</p> <pre><code>description:\nExample 6, p72\n\nThere is an Ace and a King = (There is an Ace) x (There is a king)\nv[0]: {a()}\nv[1]: {k()}\n\nc (Conclusion): {a()k()}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e7","title":"e7","text":"<p>Link to code</p> <pre><code>description:\nExample 7, p73\n\nThere is an Ace or there is a king = (There is an Ace) + (There is a king)\nv[0]: {a()}\nv[1]: {k()}\n\nc (Conclusion): {a(),k()}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e8","title":"e8","text":"<p>Link to code</p> <pre><code>description:\nExample 8, p74\n\nP1 There is an ace and a queen, or else there is a king and a ten\nP2 There is a king\n\nC There is a ten (and a king)\nv[0]: {a()q(),k()t()}\nv[1]: {k()}\n\nc (Conclusion): {t()}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e10","title":"e10","text":"<p>Link to code</p> <pre><code>description:\nExample 10, p76\n\nP1 There is a king.\nP2 There is at least an ace and a queen, or else at least a king and a ten.\nC There is a king (reversed premises blocking illusory inference).\nv[0]: {K()}\nv[1]: {A()Q(),K()T()}\n\nc (Conclusion): {K()}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e11","title":"e11","text":"<p>Link to code</p> <pre><code>description:\nExample 11, p77\n\nP1 Either John smokes or Mary smokes.\nP2 Supposing John smokes, John drinks.\nP3 Supposing Mary smokes, Mary eats.\nC Either John smokes and drinks or Mary smokes and drinks.\nv[0]: {Smokes(j()),Smokes(m())}\nv[1]: {Drinks(j())}^{Smokes(j())}\nv[2]: {Eats(m())}^{Smokes(m())}\n\nc (Conclusion): {Drinks(j())Smokes(j()),Eats(m())Smokes(m())}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e12i","title":"e12i","text":"<p>Link to code</p> <pre><code>description:\nExample 12i, p78\n\nItisnotthecasethatPorQorR\nv[0]: {P(),Q(),R()}\n\nc (Conclusion): {~P()~Q()~R()}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e12ii","title":"e12ii","text":"<p>Link to code</p> <pre><code>description:\nExample 12ii, p78\n\nItisnotthecasethatPandQandR\nv[0]: {P()Q()R()}\n\nc (Conclusion): {~P(),~Q(),~R()}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e12iii","title":"e12iii","text":"<p>Link to code</p> <pre><code>description:\nExample 12iii, p79\n\nIt is not the case that, supposing S, ((P and Q) or R)\nv[0]: {P()Q(),R()}^{S()}\n\nc (Conclusion): {S()~P()~R(),S()~Q()~R()}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e13","title":"e13","text":"<p>Link to code</p> <pre><code>description:\nExample 13, p80\n\nP1 There is an ace and a king or a queen and a jack.\nP2 There isn't an ace.\nC There is a queen and a jack.\nv[0]: {IsAce()IsKing(),IsJack()IsQueen()}\nv[1]: {~IsAce()}\n\nc (Conclusion): {IsJack()IsQueen()}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e14_1","title":"e14_1","text":"<p>Link to code</p> <pre><code>description:\nExample 14-1, p81\n\nFactor examples\nv[0]: {P()Q(),P()R()}\nv[1]: {P()}\n\nc (Conclusion): {Q(),R()}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e14_2","title":"e14_2","text":"<p>Link to code</p> <pre><code>description:\nExample 14-2, p81\n\nFactor examples\nv[0]: {P()Q()S(),P()R(),P()R()S()}\nv[1]: {P()}^{S()}\n\nc (Conclusion): {P()R(),Q()S(),R()S()}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e14_3","title":"e14_3","text":"<p>Link to code</p> <pre><code>description:\nExample 14-3, p81\n\nFactor examples\nv[0]: {P()R(),P()S(),Q()R(),Q()S()}\nv[1]: {P(),Q()}\n\nc (Conclusion): {R(),S()}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e14_6","title":"e14_6","text":"<p>Link to code</p> <pre><code>description:\nExample 14-6, p81\n\nFactor examples\nv[0]: {P()R(),Q()S()}\nv[1]: {P(),Q(),T()}\n\nc (Conclusion): {P()R(),Q()S()}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e14_7","title":"e14_7","text":"<p>Link to code</p> <pre><code>description:\nExample 14-7, p81\n\nFactor examples\nv[0]: {P(),P()R(),Q()S()}\nv[1]: {P(),Q()}\n\nc (Conclusion): {0,R(),S()}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e15","title":"e15","text":"<p>Link to code</p> <pre><code>description:\nExample 15, p82\n\nP1 There is an ace and a jack and a queen, or else there is an eight and a ten and a four, or else there is an ace.\nP2 There is an ace and a jack, and there is an eight and a ten.\nP3 There is not a queen.\nC There is a four\nv[0]: {Ace(),Ace()Jack()Queen(),Eight()Four()Ten()}\nv[1]: {Ace()Eight()Jack()Ten()}\nv[2]: {~Queen()}\n\nc (Conclusion): {Four()}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e16","title":"e16","text":"<p>Link to code</p> <pre><code>description:\nExample 16, p83\n\nP1 There is a ten and an eight and a four, or else there is a jack and a king and a queen, or else there is an ace.\nP2 There isn't a four.\nP3 There isn't an ace.\nv[0]: {Ace(),Eight()Four()Ten(),Jack()King()Queen()}\nv[1]: {~Four()}\nv[2]: {~Ace()}\n\nc (Conclusion): {Jack()King()Queen()}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e17","title":"e17","text":"<p>Link to code</p> <pre><code>description:\nExample 17, p83\n\nP1 There is a king in the hand and there is not an ace in the hand, or else there is an ace in the hand and there is not a king in the hand.\nP2 There is a king in the hand.\nC There isn't an ace in the hand.\nv[0]: {Ace()~King(),King()~Ace()}\nv[1]: {King()}\n\nc (Conclusion): {~Ace()}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e19","title":"e19","text":"<p>Link to code</p> <pre><code>description:\nExample 19, p84\n\nSuppose test\nv[0]: {0}\nv[1]: {~N()}\n\nc (Conclusion): {~N()}^{~N()}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e20","title":"e20","text":"<p>Link to code</p> <pre><code>description:\nExample 20, p85\n\nP1 Either there is a king in the hand or a queen in the hand.\nP2 On the supposition that there is a king, Mary wins.\nP3 On the supposition that there is a queen, Bill wins.\nC Either Mary wins or Bill wins.\nv[0]: {King(),Queen()}\nv[1]: {Win(mary())}^{King()}\nv[2]: {Win(bill())}^{Queen()}\n\nc (Conclusion): {Win(bill()),Win(mary())}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e21","title":"e21","text":"<p>Link to code</p> <pre><code>description:\nExample 21, p86\n\nAny view \u0394^{0} = [\u0394^{0}]\u1db0 can be derived from the absurd view\nv[0]: {r1()s1()}\n\nc (Conclusion): {~r1(),~s1()}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e22","title":"e22","text":"<p>Link to code</p> <pre><code>description:\nExample 22, p87\n\nIt is not the case that A and B and C\nv[0]: {a()b()c()}\nv[1]: {a()}\nv[2]: {b()}\nv[3]: {c()}\n\nv[0]: {~a(),~b(),~c()}\nv[1]: {a()b()~c(),a()c()~b(),a()~b()~c(),b()c()~a(),b()~a()~c(),c()~a()~b(),~a()~b()~c()}\n\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e23_with_inquire","title":"e23_with_inquire","text":"<p>Link to code</p> <pre><code>description:\nExample 23, p88, with inquire step\n\nP1 Either Jane is kneeling by the fire and she is looking at the TV or else Mark is\nstanding at the window and he is peering into the garden.\nP2 Jane is kneeling by the fire\n\nC Jane is looking at the TV\nv[0]: {K()L(),P()S()}\nv[1]: {K()}\n\nv[0]: {K()L(),K()P()S(),P()S()~K()}\nv[1]: {K()L(),K()P()S()}\n\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e23_without_inquire","title":"e23_without_inquire","text":"<p>Link to code</p> <pre><code>description:\nExample 23, p88, without inquire step\n\nP1 Either Jane is kneeling by the fire and she is looking at the TV or else Mark is\nstanding at the window and he is peering into the garden.\nP2 Jane is kneeling by the fire\n\nC Jane is looking at the TV\nv[0]: {K()L(),P()S()}\nv[1]: {K()}\n\nv[0]: {K()L(),P()S()}\nv[1]: {K()L()}\n\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e24","title":"e24","text":"<p>Link to code</p> <pre><code>description:\nExample 24, p89\n\nP1 There is an ace\nC There is an ace or a queen\nv[0]: {a()}\nv[1]: {q()}\nv[2]: {~q()}\nv[3]: {a(),q()}\n\nv[0]: {a()q(),a()~q()}\nv[1]: {a(),q()}\n\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e25i","title":"e25i","text":"<p>Link to code</p> <pre><code>description:\nExample 25i, p89\nv[0]: {p()q(),p()r()}\nv[1]: {p()}\n\nc (Conclusion): {p()}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e25ii","title":"e25ii","text":"<p>Link to code</p> <pre><code>description:\nExample 25ii, p89\nv[0]: {p()q(),p()r()}\nv[1]: {q()}\n\nc (Conclusion): {0,q()}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e25iii","title":"e25iii","text":"<p>Link to code</p> <pre><code>description:\nExample 25iii, p89\nv[0]: {p()q(),p()r(),s(),t()}\nv[1]: {p(),s()}\n\nc (Conclusion): {0,p(),s()}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e25iv","title":"e25iv","text":"<p>Link to code</p> <pre><code>description:\nExample 25iv, p89\nv[0]: {p()q(),p()r(),s(),t()}\nv[1]: {p(),s(),t()}\n\nc (Conclusion): {p(),s(),t()}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e25v","title":"e25v","text":"<p>Link to code</p> <pre><code>description:\nExample 25v, p89\nv[0]: {p()q()s(),p()r()s()}\nv[1]: {p()}^{s()}\n\nc (Conclusion): {p()}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e25vi","title":"e25vi","text":"<p>Link to code</p> <pre><code>description:\nExample 25vi, p89\nv[0]: {p()q()s(),p()r()s()}\nv[1]: {p()}^{t()}\n\nc (Conclusion): {0}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e26","title":"e26","text":"<p>Link to code</p> <pre><code>description:\nExample 26, p90\n\nP1 Either John plays and wins, or Mary plays, or Bill plays\nC Supposing John plays, John wins\nv[0]: {Play(B()),Play(J())Win(J()),Play(M())}\nv[1]: {Play(J())}\nv[2]: {Win(J())}^{Play(J())}\n\nv[0]: {Play(J())Win(J())}^{Play(J())}\nv[1]: {Win(J())}^{Play(J())}\n\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e26_does_it_follow","title":"e26_does_it_follow","text":"<p>Link to code</p> <pre><code>description:\nExample 26, p90\n\nP1 Either John plays and wins, or Mary plays, or Bill plays\nC Supposing John plays, John wins\nv[0]: {Play(B()),Play(J())Win(J()),Play(M())}\nv[1]: {Play(J())}\nv[2]: {Win(J())}^{Play(J())}\n\nv[0]: {Play(J())Win(J())}^{Play(J())}\nv[1]: {Win(J())}^{Play(J())}\n\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e28","title":"e28","text":"<p>Link to code</p> <pre><code>description:\nExample 28, p96\n\nP1 Is there a tiger?\nP2 Supposing there is a tiger, there is orange fur.\nP3 There is orange fur.\nC There is a tiger.\nv[0]: {Tiger(),~Tiger()}\nv[1]: {Orange()Tiger()}^{Tiger()}\nv[2]: {Orange()}\n\nc (Conclusion): {Orange()Tiger()}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e32_1","title":"e32_1","text":"<p>Link to code</p> <pre><code>description:\nExample 32-1, p107\n\nP1 If P then Q.\nP2 P\nC Q\nv[0]: {P()Q()}^{P()}\nv[1]: {P()}\n\nc (Conclusion): {Q()}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e32_2","title":"e32_2","text":"<p>Link to code</p> <pre><code>description:\nExample 32-2, p107\n\nP1 P\nP2 If P then Q.\nC Q\nv[0]: {P()}\nv[1]: {P()Q()}^{P()}\n\nc (Conclusion): {Q()}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e33","title":"e33","text":"<p>Link to code</p> <pre><code>description:\nExample 33, p108\n\nP1 If the card is red then the number is even.\nP2 The number is even.\nC The card is red\nv[0]: {E()R()}^{R()}\nv[1]: {E()}\n\nc (Conclusion): {R()}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e40i","title":"e40i","text":"<p>Link to code</p> <pre><code>description:\nExample 40, p119\n\n(P0 Shapes at the bottom of the card are mutually exclusive)\nP1 If there is a circle at the top of the card, then there is a\nsquare on the bottom.\nP2 There is a triangle on the bottom\nC Falsum\nv[0]: {CircleB()~SquareB()~TriangleB(),SquareB()~CircleB()~TriangleB(),TriangleB()~CircleB()~SquareB()}\nv[1]: {CircleT()SquareB()}^{CircleT()}\nv[2]: {TriangleB()}\n\nc (Conclusion): {}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e40ii","title":"e40ii","text":"<p>Link to code</p> <pre><code>description:\nExample 40, p119-p120\n\n(P0 Shapes at the bottom of the card are mutually exclusive)\nP1 If there is a circle at the top of the card, then there is a\nsquare on the bottom.\nP2 There is a triangle on the bottom\nC Falsum\n\nThe reader diverges from the default procedure,\nand deposes the conditional premise, and switches the premise\norder.\nv[0]: {CircleB()~SquareB()~TriangleB(),SquareB()~CircleB()~TriangleB(),TriangleB()~CircleB()~SquareB()}\nv[1]: {TriangleB()}\nv[2]: {CircleT()SquareB()}^{CircleT()}\n\nc (Conclusion): {TriangleB()~CircleB()~CircleT()~SquareB()}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e41","title":"e41","text":"<p>Link to code</p> <pre><code>description:\nExample 41, p121\n\nP1 P only if Q.\nP2 Not Q.\nC Not P.\nv[0]: {~P()~Q()}^{~Q()}\nv[1]: {~Q()}\n\nc (Conclusion): {~P()}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e42","title":"e42","text":"<p>Link to code</p> <pre><code>description:\nExample 42, p122\n\nP1 There is a circle at the top of the card only if there is a square\nat the bottom.\nP2 There is not a square at the bottom\nC There is not a circle at the top\nv[0]: {~CircleT()~SquareB()}^{~SquareB()}\nv[1]: {~SquareB()}\n\nc (Conclusion): {~CircleT()}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e44_1","title":"e44_1","text":"<p>Link to code</p> <pre><code>description:\nExample 44-1, p123\n\nP1 The chair is saleable if and only if it is inelegant.\nP2 The chair is elegant if and only if it is stable.\nP3 The chair is saleable or it is stable, or both.\nC The chair is saleable elegant and stable.\nv[0]: {Elegant(c())Saleable(c()),~Elegant(c())~Saleable(c())}\nv[1]: {Elegant(c())Stable(c()),~Elegant(c())~Stable(c())}\nv[2]: {Elegant(c())Saleable(c()),Saleable(c()),Stable(c())}\n\nc (Conclusion): {Elegant(c())Saleable(c())Stable(c())}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e45","title":"e45","text":"<p>Link to code</p> <pre><code>description:\nExample 45, p125\n\nIt is possible that Steven is in Madrid and it is possible that Emma is in\nBerlin.\nTherefore it is possible that Steven is in Madrid and that Emma is in Berlin.\nv[0]: {0,M()}\nv[1]: {0,B()}\nv[2]: {0,B()M()}\n\nv[0]: {0,B(),B()M(),M()}\nv[1]: {0,B()M()}\n\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e46i","title":"e46i","text":"<p>Link to code</p> <pre><code>description:\nExample 46, p126\n\nP1 Pat is here then Viv is here\nP2 Mo is here or else Pat is here, but not both\n\nC No\nv[0]: {P()V()}^{P()}\nv[1]: {M()~P(),P()~M()}\nv[2]: {0,M()V()}\n\nv[0]: {M()~P(),P()V()~M()}\nv[1]: {0}\n\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e46ii","title":"e46ii","text":"<p>Link to code</p> <pre><code>description:\nExample 46, part ii, p126\n\nIf we had a view{VMR,VMS, T} and applied [{vm, 0}]Q we would get [{vm, 0}]\nv[0]: {M()R()V(),M()S()V(),T()}\nv[1]: {0,M()V()}\n\nc (Conclusion): {0,M()V()}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e47","title":"e47","text":"<p>Link to code</p> <pre><code>description:\nExample 47, p129\n\nP1: Some thermotogum stains gram-negative\nP2: Maritima is a thermotogum\n\nC: Maritima stains gram negative\nv[0]: \u2203x {StainsGramNegative(x)Thermotogum(x*)}\nv[1]: {Thermotogum(Maritima()*)}\n\nc (Conclusion): {StainsGramNegative(Maritima())}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e48","title":"e48","text":"<p>Link to code</p> <pre><code>description:\nExample 48, p130\n\nP1 Some dictyoglomus is thermophobic.\nP2 Turgidum is not a dictyoglomus.\nC Truth\nv[0]: \u2203x {D(x*)T(x)}\nv[1]: {~D(Turgidum()*)}\n\nc (Conclusion): {0}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e49","title":"e49","text":"<p>Link to code</p> <pre><code>description:\nExample 49, p130\n\nP1 Either there is an ace in Mary's hand and some other player has a king,\nor else there is a queen in John's hand and some other player has a jack.\nP2 Sally has a king\nC Truth\nv[0]: \u2203x \u2203y {Ace(Mary())King(x),Jack(y)Queen(John())}\nv[1]: {King(Sally())}\n\nc (Conclusion): {0}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e50_part1","title":"e50_part1","text":"<p>Link to code</p> <pre><code>description:\nExample 50, part1, p131\n\nJack is looking at Sally, but Sally is looking at George. Jack is married, but George is\nnot. Is the married person looking at an unmarried person?\n\n(A) Yes\n(B) No\n(C) Cannot be determined\nv[0]: {L(j(),s())L(s(),g())}\nv[1]: {M(j()*)~M(g()*)}\nv[2]: {}\nv[3]: \u2203a \u2203b {L(a,b)M(a*)~M(b*)}\n\nv[0]: {L(j(),s())L(s(),g())M(j()*)~M(g()*)}\nv[1]: {0}\n\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e50_part2","title":"e50_part2","text":"<p>Link to code</p> <pre><code>description:\nExample 50, part2, p131\n\nJack is looking at Sally, but Sally is looking at George. Jack is married, but George is\nnot. Is the married person looking at an unmarried person?\n\n(A) Yes\n(B) No\n(C) Cannot be determined\nv[0]: {L(j(),s())L(s(),g())}\nv[1]: {M(j())~M(g())}\nv[2]: {M(s())}\nv[3]: \u2203a \u2203b {L(a,b)M(a*)~M(b*)}\n\nc (Conclusion): \u2203a \u2203b {L(a,b)M(a*)~M(b*)}\ng1 (Another View): {L(j(),s())L(s(),g())M(j())M(s())~M(g()),L(j(),s())L(s(),g())M(j())~M(g())~M(s())}\ng2 (Another View): {L(j(),s())L(s(),g())M(j()*)M(s())~M(g()*),L(j(),s())L(s(),g())M(j()*)~M(g()*)~M(s()*)}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e50_part2_arbs","title":"e50_part2_arbs","text":"<p>Link to code</p> <pre><code>description:\nDuplicate of e50, uses arb objects, some changes\nv[0]: \u2203g \u2203j \u2203s {L(j,s)L(s,g)M(j)~M(g)}\nv[1]: \u2203s {M(s)}\nv[2]: \u2203a \u2203b {L(a,b)M(a*)~M(b*)}\n\nc (Conclusion): \u2203a \u2203b {L(a,b)M(a*)~M(b*)}\ng1 (Another View): \u2203g \u2203j \u2203s {L(j,s)L(s,g)M(j)M(s)~M(g),L(j,s)L(s,g)M(j)~M(g)~M(s)}\ng2 (Another View): \u2203g \u2203j \u2203s {L(j,s)L(s,g)M(j*)M(s)~M(g*),L(j,s)L(s,g)M(j*)~M(g*)~M(s*)}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e51","title":"e51","text":"<p>Link to code</p> <pre><code>description:\nExample 51, p131\n\nP1: Every archaeon has a nucleus\nP2: Halobacterium is an archaeon\n\nC: Halobacterium is an archaeon and has a nucleus\nv[0]: \u2200x {HasNucleus(x)IsArchaeon(x*)}^{IsArchaeon(x*)}\nv[1]: {IsArchaeon(Halobacterium()*)}\n\nc (Conclusion): {HasNucleus(Halobacterium())IsArchaeon(Halobacterium()*)}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e52","title":"e52","text":"<p>Link to code</p> <pre><code>description:\nExample 52, p132\n\nP1 All Fs G.\nP2 John Gs.\nC John Fs and Gs.\nv[0]: \u2200x {F(x)G(x*)}^{F(x)}\nv[1]: {G(John()*)}\n\nc (Conclusion): {F(John())G(John()*)}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e53","title":"e53","text":"<p>Link to code</p> <pre><code>description:\nExample 53, p132 &amp; p175\n\nP All A are B.\nC All B are A.\nv[0]: \u2200x {A(x)B(x)}^{A(x)}\nv[1]: \u2200x {B(x)}\nv[2]: \u2200x {A(x)B(x)}^{B(x)}\n\nc (Conclusion): \u2200x {A(x)B(x)}^{B(x)}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e53_does_it_follow","title":"e53_does_it_follow","text":"<p>Link to code</p> <pre><code>description:\nExample 53, p132 &amp; p175\n\nP All A are B.\nC All B are A.\nv[0]: \u2200x {A(x)B(x)}^{A(x)}\nv[1]: \u2200x {B(x)}\nv[2]: \u2200x {A(x)B(x)}^{B(x)}\n\nc (Conclusion): \u2200x {A(x)B(x)}^{B(x)}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e54","title":"e54","text":"<p>Link to code</p> <pre><code>description:\nExample 54, p133\n\nP1 Sharks attack bathers.\nP2 Whitey is a shark.\nC Whitey attacks bathers.\nv[0]: \u2200x {0,Attack(x)Shark(x*)}^{Shark(x*)}\nv[1]: {Shark(Whitey()*)}\n\nc (Conclusion): {Attack(Whitey())Shark(Whitey()*)}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e56_default_inference","title":"e56_default_inference","text":"<p>Link to code</p> <pre><code>description:\nExample 56, p134\n\nP1: Every professor teaches some student\nP2: Every student reads some book\n\nC: Every professor teaches some student who reads some book\nv[0]: \u2200x \u2203y {Professor(x)Student(y*)Teaches(x,y)}^{Professor(x)}\nv[1]: \u2200z \u2203w {Book(w)Reads(z,w)Student(z*)}^{Student(z*)}\n\nc (Conclusion): \u2203b \u2203y {0,Book(b)Reads(y,b)}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e56_basic_step","title":"e56_basic_step","text":"<p>Link to code</p> <pre><code>description:\nExample 56, p134\n\nP1: Every professor teaches some student\nP2: Every student reads some book\n\nC: Every professor teaches some student who reads some book\nv[0]: \u2200x \u2203y {Professor(x)Student(y*)Teaches(x,y)}^{Professor(x)}\nv[1]: \u2200z \u2203w {Book(w)Reads(z,w)Student(z*)}^{Student(z*)}\n\nc (Conclusion): \u2200a \u2203b \u2203c {Book(c)Professor(a)Reads(b,c)Student(b*)Teaches(a,b),~Professor(a)}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e57","title":"e57","text":"<p>Link to code</p> <pre><code>description:\nExample 57, p134\n\nP1 All B are A.\nP2 Some C are B.\nC Some C are A.\nv[0]: \u2200x {A(x)B(x*)}^{B(x*)}\nv[1]: \u2203x {B(x*)C(x)}\n\nc (Conclusion): \u2203y {A(y)B(y*)C(y)}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e58_reversed","title":"e58_reversed","text":"<p>Link to code</p> <pre><code>description:\nExample 58 reversed, based on p135\n\nP1 All C are B.\nP2 Some B are A.\nC Some C are A.\nv[0]: \u2200y {B(y*)C(y)}^{C(y)}\nv[1]: \u2203x {A(x)B(x*)}\n\nc (Conclusion): \u2203y {A(y)B(y*)C(y)}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e61","title":"e61","text":"<p>Link to code</p> <pre><code>description:\nExample 61, p166\nP1 All dogs bite some man\nP2 John is a man\n\nC All dogs bite John\nv[0]: \u2200x \u2203a {B(x,a)D(x)M(a*),~D(x)}\nv[1]: {M(j()*)}\n\nc (Conclusion): \u2200x \u2203a {B(x,a)D(x)M(a*)M(j()*),M(j()*)~D(x)}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e62","title":"e62","text":"<p>Link to code</p> <pre><code>description:\nExample 62, p176\nv[0]: {D(b())~S(n()*),D(m())S(j()*)T(n()),L(n(),m())S(m()*)}\nv[1]: \u2203a {S(a*)}\n\nc (Conclusion): {0,S(j()*),S(m()*)}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e63","title":"e63","text":"<p>Link to code</p> <pre><code>description:\nExample 63, p176\nv[0]: {D(n()*)S(j()*),D(n()*)T(j())~D(j()*)}\nv[1]: \u2203a {D(a*)}\n\nc (Conclusion): {D(n()*)}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e63_modified","title":"e63_modified","text":"<p>Link to code</p> <pre><code>description:\nExample 63, p176\nv[0]: \u2200x \u2203y {D(f(y,x)*)T(j())~D(j()*),D(n()*)S(j()*)}\nv[1]: \u2203a {D(a*)}\n\nc (Conclusion): \u2200x \u2203y {D(f(y,x)*),D(n()*)}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e64i","title":"e64i","text":"<p>Link to code</p> <pre><code>description:\nExample 64, p189, p223\n\nA device has been invented for screening a population for a disease known as psylicrapitis.\nThe device is a very good one, but not perfect. If someone is a sufferer, there is a 90% chance\nthat he will recorded positively. If he is not a sufferer, there is still a 1% chance that he will\nbe recorded positively.\n\nRoughly 1% of the population has the disease. Mr Smith has been tested, and the result is positive.\n\nWhat is the chance that he is in fact a sufferer?\nv[0]: \u2200x {90.0=* S(x*)T(x*),S(x*)~T(x)}^{S(x*)}\nv[1]: \u2200x {1.0=* T(x)~S(x*),~S(x*)~T(x)}^{~S(x*)}\nv[2]: {T(Smith()*)}\nv[3]: {S(Smith())}\n\nc (Conclusion): {0,90.0=* S(Smith()*)}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e64ii","title":"e64ii","text":"<p>Link to code</p> <pre><code>description:\nExample 64, p189, p223\n\nA device has been invented for screening a population for a disease known as psylicrapitis.\nThe device is a very good one, but not perfect. If someone is a sufferer, there is a 90% chance\nthat he will recorded positively. If he is not a sufferer, there is still a 1% chance that he will\nbe recorded positively.\n\nRoughly 1% of the population has the disease. Mr Smith has been tested, and the result is positive.\n\nWhat is the chance that he is in fact a sufferer?\nv[0]: \u2200x {90.0=* P(x)S(x*)T(x*),P(x)S(x*)~T(x)}^{P(x)S(x*)}\nv[1]: \u2200x {1.0=* P(x)T(x)~S(x*),P(x)~S(x*)~T(x)}^{P(x)~S(x*)}\nv[2]: \u2200x {1.0=* P(x)S(x*),P(x)~S(x)}^{P(x)}\nv[3]: {P(Smith())T(Smith()*)}\nv[4]: {S(Smith())}\n\nc (Conclusion): {90.0=* S(Smith()*)}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e65","title":"e65","text":"<p>Link to code</p> <pre><code>description:\nExample 65, p190, p224\n\n(Base-rate neglect with doctors and realistic disease) Imagine you conduct\na screening using the Hemoccult test in a certain region. For symptom-free\npeople over 50 years old who participate in screening using the Hemoccult test,\nthe following information is available for this region.\n\nThe probability that one of these people has colorectal cancer is 0.3%. If a\nperson has colorectal cancer, the probability is 50 that he will have a positive\nHemoccult test. If a person does not have a colorectal cancer, the probability is\n3% that he will still have a positive Hemoccult test in your screening. What is\nthe probability that this person actually has colorectal cancer?\nv[0]: \u2200x {0.3=* C(x)P(x*),P(x*)~C(x)}^{P(x*)}\nv[1]: \u2200x {50.0=* C(x)P(x*)T(x),C(x)P(x*)~T(x)}^{C(x)P(x*)}\nv[2]: \u2200x {3.0=* P(x*)T(x)~C(x),P(x*)~C(x)~T(x)}^{P(x*)~C(x)}\nv[3]: \u2203a {P(a*)T(a)}\nv[4]: \u2203a {C(a)}\n\nc (Conclusion): \u2203a {0,15.0=* C(a)}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e66i","title":"e66i","text":"<p>Link to code</p> <pre><code>description:\nExample 66, p191, p225\n\nThink of 100 people.\n\n1. One of the disease psylicrapitis, and he is likely to be positive.\n2. Of those who do not have the disease, 1 will also test positive.\n\nHow many of those who test positive do have the disease? Out of ?\nv[0]: {1.0=* D()T(),1.0=* T()~D(),98.0=* ~D()}\nv[1]: {D()T()}\n\nc (Conclusion): {}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e66ii","title":"e66ii","text":"<p>Link to code</p> <pre><code>description:\nExample 66, p191, p225\n\nThink of 100 people.\n\n1. One of the disease psylicrapitis, and he is likely to be positive.\n2. Of those who do not have the disease, 1 will also test positive.\n\nHow many of those who test positive do have the disease? Out of ?\nv[0]: {1.0=* D()T(),1.0=* T()~D(),98.0=* ~D()}\nv[1]: {T()}\n\nc (Conclusion): {}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e67","title":"e67","text":"<p>Link to code</p> <pre><code>description:\nExample 67, p191, p220\n\nResults of a recent survey of seventy-four chief executive officers indicate there\nmay be a link between childhood pet ownership and future career success. Fully 94%\nof the CEOs, all of them employed within Fortune 500 companies, had possessed a dog,\na cat, or both, as youngsters.\nv[0]: {94.0=* HadPet()IsCEO(),~IsCEO()}\nv[1]: {HadPet()}\nv[2]: {IsCEO()}\n\nc (Conclusion): {0,94.0=* IsCEO()}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e69_part1","title":"e69_part1","text":"<p>Link to code</p> <pre><code>description:\nExample 69, p192, p218\n\nThe suspect's DNA matches the crime sample.\n\nIf the suspect is not guilty, then the probability of such a DNA match is 1 in\na million\n\nIs the suspect likely to be guilty?\nv[0]: {Match(Suspect())}\nv[1]: {0.000001=* Match(Suspect())~Guilty(Suspect()),~Guilty(Suspect())~Match(Suspect())}^{~Guilty(Suspect())}\n\nc (Conclusion): {Guilty(Suspect())Match(Suspect()),0.000001=* Match(Suspect())~Guilty(Suspect())}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e69_part2","title":"e69_part2","text":"<p>Link to code</p> <pre><code>description:\nThe base class for all examples. It contains a series of views (v)\nfor operations and a conclusion (c).\nv[0]: {Guilty(Suspect())Match(Suspect()),0.000001=* Match(Suspect())~Guilty(Suspect())}\nv[1]: {999999.999999=* 0}^{Guilty(Suspect())Match(Suspect())}\nv[2]: {Guilty(Suspect())}\n\nv[0]: {999999.999999=* Guilty(Suspect())Match(Suspect()),0.000001=* Match(Suspect())~Guilty(Suspect())}\nv[1]: {0,999999.999999=* Guilty(Suspect())}\n\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e70","title":"e70","text":"<p>Link to code</p> <pre><code>description:\nExample 70, p194, p221\n\nP1 Pat has either the disease or a benign condition\nP2 If she has the disease, then she will have a certain symptom.\nP3 In fact, she has the symptom\nv[0]: {Benign(),Disease()}\nv[1]: {Disease()Symptom()}^{Disease()}\nv[2]: {Symptom()}\n\nc (Conclusion): {Disease()Symptom()}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e71","title":"e71","text":"<p>Link to code</p> <pre><code>description:\nExamples 71 &amp; 78, p209, p212\n\nThere is a box in which there is a yellow card or a brown card, but not both.\n\nGiven the preceding assertion, according to you, what is the probability of the following situation?\n\nIn the box there is a yellow card and there is not a brown card\nv[0]: {B(brown())~B(yellow()),B(yellow())~B(brown())}\nv[1]: {50.0=* 0}^{B(yellow())~B(brown())}\nv[2]: {50.0=* 0}^{B(brown())~B(yellow())}\nv[3]: {B(yellow())~B(brown())}\n\nv[0]: {50.0=* B(brown())~B(yellow()),50.0=* B(yellow())~B(brown())}\nv[1]: {0,50.0=* B(yellow())~B(brown())}\n\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e72","title":"e72","text":"<p>Link to code</p> <pre><code>description:\nExample 72 &amp; 80, p196, p213\n\nThere is a box in which there is at least a red marble or else there is a green\nmarble and there is a blue marble, but not all three marbles.\n\nWhat is the probability of the following situation:\n\nThere is a red marble and a blue marble in the box?\nv[0]: {B(b())B(g())~B(r()),B(r())~B(b()),B(r())~B(g())}\nv[1]: {33.333333=* 0}^{B(b())B(g())~B(r())}\nv[2]: {33.333333=* 0}^{B(r())~B(g())}\nv[3]: {33.333333=* 0}^{B(r())~B(b())}\nv[4]: {B(b())B(r())}\n\nv[0]: {33.333333=* B(b())B(g())~B(r()),33.333333=* B(r())~B(b()),33.333333=* B(r())~B(g())}\nv[1]: {0,33.333333=* B(b())B(r())}\n\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e74","title":"e74","text":"<p>Link to code</p> <pre><code>description:\nExample 74, p197, p231\n\n(includes two background commitments)\nv[0]: {D(j())H(j()),H(j()),P(j())}\nv[1]: {E(j()*)}\nv[2]: \u2200x {0.85=* D(x)E(x*),0.15=* E(x*)~D(x)}^{E(x*)}\nv[3]: \u2200x {0.1=* E(x*)H(x),0.9=* E(x*)~H(x)}^{E(x*)}\n\nv[0]: {0.085=* D(j())E(j()*)H(j()),0.765=* D(j())E(j()*)~H(j()),0.015=* E(j()*)H(j())~D(j()),0.135=* E(j()*)~D(j())~H(j())}\nv[1]: {D(j())H(j())}\n\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e76","title":"e76","text":"<p>Link to code</p> <pre><code>description:\nExample 76 (guns and guitars), p199, p226,  p229\n\n(P1) The gun fired and the guitar was out of tune, or else someone was in the attic\n(P1.5, see p228) Guns who triggers are pulled fire\n(P2) The trigger (of the gun) was pulled. Does it follow that the guitar was out of\ntune?\nv[0]: {Attic(a()),Fired(i()*)Guitar(j())Gun(i())Outoftune(j())}\nv[1]: \u2200x {0,Fired(x*)Gun(x)Trigger(x)}^{Fired(x*)Gun(x)}\nv[2]: {Trigger(i())}\n\nc (Conclusion): {Fired(i()*)Guitar(j())Gun(i())Outoftune(j())Trigger(i())}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e81i","title":"e81i","text":"<p>Link to code</p> <pre><code>description:\nExample 81, p213\n\nThere is a box in which there is a yellow card, or a brown card, but not both\n\nGiven the preceding assertion, according to you, what is the probability of the following situation?\n\nIn the box there is a yellow card\nv[0]: {Box(Brown())~Box(Yellow()),Box(Yellow())~Box(Brown())}\n\nc (Conclusion): {0,50.0=* Box(Yellow())}\nprob (Probability): {Box(Yellow())}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e81ii","title":"e81ii","text":"<p>Link to code</p> <pre><code>description:\nExample 81, p213\n\nThere is a box in which there is a yellow card, or a brown card, but not both\n\nGiven the preceding assertion, according to you, what is the probability of the following situation?\n\nIn the box there is a yellow card and a brown card\nv[0]: {Box(Brown())~Box(Yellow()),Box(Yellow())~Box(Brown())}\n\nc (Conclusion): {0}\nprob (Probability): {Box(Brown())Box(Yellow())}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e81iii","title":"e81iii","text":"<p>Link to code</p> <pre><code>description:\nExample 81, p213\n\nThere is a box in which there is a yellow card, or a brown card, but not both\n\nGiven the preceding assertion, according to you, what is the probability of the following situation?\n\nIn the box there is neither a yellow card nor a brown card\nv[0]: {Box(Brown())~Box(Yellow()),Box(Yellow())~Box(Brown())}\n\nc (Conclusion): {0}\nprob (Probability): {~Box(Brown())~Box(Yellow())}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e82i","title":"e82i","text":"<p>Link to code</p> <pre><code>description:\nExample 82, p213\n\nThere is a box in which if there is a yellow card then there is a brown card.\n\nGiven the preceding assertion, according to you, what is the probability of the\nfollowing situation?\n\nIn the box there is a yellow card.\nv[0]: {Box(Brown())Box(Yellow())}^{Box(Yellow())}\n\nc (Conclusion): {0,50.0=* Box(Yellow())}\nprob (Probability): {Box(Yellow())}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e82ii","title":"e82ii","text":"<p>Link to code</p> <pre><code>description:\nExample 82, p213\n\nThere is a box in which if there is a yellow card then there is a brown card.\n\nGiven the preceding assertion, according to you, what is the probability of the\nfollowing situation?\n\nIn the box there is a yellow card and a brown card.\nv[0]: {Box(Brown())Box(Yellow())}^{Box(Yellow())}\n\nc (Conclusion): {0,50.0=* Box(Brown())Box(Yellow())}\nprob (Probability): {Box(Brown())Box(Yellow())}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e82iii","title":"e82iii","text":"<p>Link to code</p> <pre><code>description:\nExample 82, p213\n\nThere is a box in which if there is a yellow card then there is a brown card.\n\nGiven the preceding assertion, according to you, what is the probability of the\nfollowing situation?\n\nIn the box there is a yellow card and there is not a brown card.\nv[0]: {Box(Brown())Box(Yellow())}^{Box(Yellow())}\n\nc (Conclusion): {0}\nprob (Probability): {Box(Yellow())~Box(Brown())}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e82iv","title":"e82iv","text":"<p>Link to code</p> <pre><code>description:\nExample 82, p213\n\nThere is a box in which if there is a yellow card then there is a brown card.\n\nGiven the preceding assertion, according to you, what is the probability of the\nfollowing situation?\n\nIn the box there is neither a yellow card nor a brown card.\nv[0]: {Box(Brown())Box(Yellow())}^{Box(Yellow())}\n\nc (Conclusion): {0}\nprob (Probability): {~Box(Brown())~Box(Yellow())}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e83i","title":"e83i","text":"<p>Link to code</p> <pre><code>description:\nExample 83, p214\n\nThere is a box in which there is a red marble, or else there is a green\nmarble and there is a blue marble, but not all three marbles.\n\nGiven the preceding assertion, according to you, what is the probability of the\nfollowing situation?\n\nThere is a red marble and blue in marble in the box.\nv[0]: {33.333333333333336=* Box(Blue())Box(Green()),33.333333333333336=* Box(Red()),33.333333333333336=* ~Box(Blue())~Box(Green())~Box(Red())}\n\nc (Conclusion): {0}\nprob (Probability): {Box(Blue())Box(Red())}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e83ii","title":"e83ii","text":"<p>Link to code</p> <pre><code>description:\nExample 83, p214\n\nThere is a box in which there is a red marble, or else there is a green\nmarble and there is a blue marble, but not all three marbles.\n\nGiven the preceding assertion, according to you, what is the probability of the\nfollowing situation?\n\nThere is a green marble and there is a blue marble.\nv[0]: {33.333333333333336=* Box(Blue())Box(Green()),33.333333333333336=* Box(Red()),33.333333333333336=* ~Box(Blue())~Box(Green())~Box(Red())}\n\nc (Conclusion): {0,33.333333333333336=* Box(Blue())Box(Green())}\nprob (Probability): {Box(Blue())Box(Green())}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e84i","title":"e84i","text":"<p>Link to code</p> <pre><code>description:\nExample 84, p215\n\nThere is a box in which there is a grey marble and either a white marble or\nelse a mauve marble but not all three marbles are in the box.\n\nGiven the preceding assertion, what is the probability of the following\nsituation?\n\nIn the box there is a grey marble and there is a mauve marble.\nv[0]: {Box(Grey())Box(Mauve())~Box(White()),Box(Grey())Box(White())~Box(Mauve())}\n\nc (Conclusion): {0,50.0=* Box(Grey())Box(Mauve())}\nprob (Probability): {Box(Grey())Box(Mauve())}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e84ii","title":"e84ii","text":"<p>Link to code</p> <pre><code>description:\nExample 84, p215\n\nThere is a box in which there is a grey marble, or else a white marble, or else a mauve marble,\nbut no more than one marble.\n\nGiven the preceding assertion, what is the probability of the following\nsituation?\n\nIn the box there is a grey marble and there is a mauve marble.\nv[0]: {Box(Grey())~Box(Mauve())~Box(White()),Box(Mauve())~Box(Grey())~Box(White()),Box(White())~Box(Grey())~Box(Mauve())}\n\nc (Conclusion): {0}\nprob (Probability): {Box(Grey())Box(Mauve())}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e85","title":"e85","text":"<p>Link to code</p> <pre><code>description:\nExample 85, p216\n\nEasy partial probability inference\n\nThere is a box in which there is one and only one of these marbles: a\ngreen marble, a blue marble, or a red marble. The probability that a green\nmarble is in the box is 0.6, and the probability that a blue marble is in\nthe box is 0.2.\n\nWhat is the probability that a red marble is in the box?\nv[0]: {Box(Blue()),Box(Green()),Box(Red())}\nv[1]: {60.0=* Box(Green())}^{Box(Green())}\nv[2]: {20.0=* Box(Blue())}^{Box(Blue())}\n\nc (Conclusion): {0,20.0=* Box(Red())}\nprob (Probability): {Box(Red())}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e86","title":"e86","text":"<p>Link to code</p> <pre><code>description:\nExample 86, p217\n\nYou have a hand of several cards with only limited information about it.\n\nThere is an ace and a queen or a king and a jack or a ten.\nThe probability that there is an ace and a queen is 0.6\nThe probability that there is a king and a jack is 0.2\n\nWhat is the probability that there is a ten?\nv[0]: {A()Q(),J()K(),X()}\nv[1]: {60.0=* A()Q()}^{A()Q()}\nv[2]: {20.0=* J()K()}^{J()K()}\n\nc (Conclusion): {0,20.0=* X()}\nprob (Probability): {X()}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e88","title":"e88","text":"<p>Link to code</p> <pre><code>description:\nExample 88, p233\n\nP1: There is a 90% chance Superman can fly\nP2: Clark is superman\n\nC: There is a 90% chance Clark can fly\nv[0]: {90.0=* CanFly(Superman())}\nv[1]: {==(Clark(),Superman())}\nv[2]: {==(Clark(),Superman()*)}\nv[3]: {==(Clark(),Clark())}\n\nc (Conclusion): {90.0=* CanFly(Clark())}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e90_conda","title":"e90_condA","text":"<p>Link to code</p> <pre><code>description:\nExample 90, p249, p273\n\nImagine that you have been saving some extra money on the side to make some purchases,\nand on your most recent visit to the video store you come across a special sale of a new\nvideo. This video is one with your favourite actor or actress, and your favourite type of\nmovie (such as a comedy, drama, thriller etc.). This particular video that you are considering\nis one you have been thinking about buying a long time. It is a available at a special sale price\nof $14.99. What would you do in this situation?\nv[0]: {do(Buy(Video()*)),~do(Buy(Video()*))}\n\nc (Conclusion): {do(Buy(Video()*))}\nv[0]: \u2200x {Fun()}^{do(Buy(x*))}\n\nv[0]: {1.0=+ 0}^{Fun()}\n\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e90_condb","title":"e90_condB","text":"<p>Link to code</p> <pre><code>description:\nExample 90, p249, p273\n\nImagine that you have been saving some extra money on the side to make some purchases,\nand on your most recent visit to the video store you come across a special sale of a new\nvideo. This video is one with your favourite actor or actress, and your favourite type of\nmovie (such as a comedy, drama, thriller etc.). This particular video that you are considering\nis one you have been thinking about buying a long time. It is a available at a special sale price\nof $14.99. What would you do in this situation?\nv[0]: \u2203a {do(Buy(Video()*)),do(Buy(a*))}\n\nc (Conclusion): \u2203a {do(Buy(Video()*)),do(Buy(a*))}\nv[0]: \u2200x {Fun()}^{do(Buy(x*))}\n\nv[0]: {1.0=+ 0}^{Fun()}\n\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e92_award","title":"e92_award","text":"<p>Link to code</p> <pre><code>description:\nExample 92, p253, p274\nImagine that you serve on the jury of an only-child sole-custody case following a relatively\nmessy divorce. The facts of the case are complicated by ambiguous economic, social, and\nemotional considerations, and you decide to base your decision entirely on the following\nfew observations.\n\nParentA: average income, average health, average working hours, reasonable rapport with the\nchild, relatively social life.\n\nParentB: above-average income, very close relationship with the child, extremely active\nsocial life, lots of work-related travel, minor health problems.\n\nTo which parent would you award sole custody of the child?\nv[0]: {do(Award(ParentA()*)),do(Award(ParentB()*))}\n\nc (Conclusion): {do(Award(ParentB()*))}\nv[0]: \u2200x {Custody(x*)}^{do(Award(x*))}\nv[1]: \u2200x {~Custody(x*)}^{do(Deny(x*))}\nv[2]: {HighRapp(ParentB())LowTime(ParentB())MedRapp(ParentA())MedTime(ParentA())}\n\nv[0]: \u2200x {1.0=+ 0}^{Custody(x*)MedRapp(x)}\nv[1]: \u2200x {3.0=+ 0}^{Custody(x*)HighRapp(x)}\nv[2]: \u2200x {1.0=+ 0}^{Custody(x*)MedTime(x)}\nv[3]: \u2200x {1.0=+ 0}^{MedTime(x)~Custody(x*)}\nv[4]: \u2200x {2.0=+ 0}^{LowTime(x)~Custody(x*)}\n\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e92_deny","title":"e92_deny","text":"<p>Link to code</p> <pre><code>description:\nExample 92, p253, p274\nImagine that you serve on the jury of an only-child sole-custody case following a relatively\nmessy divorce. The facts of the case are complicated by ambiguous economic, social, and\nemotional considerations, and you decide to base your decision entirely on the following\nfew observations.\n\nParentA: average income, average health, average working hours, reasonable rapport with the\nchild, relatively social life.\n\nParentB: above-average income, very close relationship with the child, extremely active\nsocial life, lots of work-related travel, minor health problems.\n\nTo which parent would you deny sole custody of the child?\nv[0]: {do(Deny(ParentA()*)),do(Deny(ParentB()*))}\n\nc (Conclusion): {do(Deny(ParentB()*))}\nv[0]: \u2200x {Custody(x*)}^{do(Award(x*))}\nv[1]: \u2200x {~Custody(x*)}^{do(Deny(x*))}\nv[2]: {HighRapp(ParentB())LowTime(ParentB())MedRapp(ParentA())MedTime(ParentA())}\n\nv[0]: \u2200x {1.0=+ 0}^{Custody(x*)MedRapp(x)}\nv[1]: \u2200x {3.0=+ 0}^{Custody(x*)HighRapp(x)}\nv[2]: \u2200x {1.0=+ 0}^{Custody(x*)MedTime(x)}\nv[3]: \u2200x {1.0=+ 0}^{MedTime(x)~Custody(x*)}\nv[4]: \u2200x {2.0=+ 0}^{LowTime(x)~Custody(x*)}\n\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#e93_grp1","title":"e93_grp1","text":"<p>Link to code</p> <pre><code>description:\nExample 93, p255, p276\n\nThe US is preparing for the outbreak of an unusual Asian disease, which\nis expected to kill 600 people. There are two possible treatments (A) and (B)\nwith the following results:\n\n(Group 1) (A) 400 people die. (B) Nobody dies with 1/3 chance, 600 people die with 2/3 chance.\nWhich treatment would you choose?\nv[0]: {do(A()),do(B())}\n\nc (Conclusion): {do(B())}\nv[0]: {D(400.0*)}^{do(A())}\nv[1]: {0.33=* D(0.0*),~D(0.0)}^{do(B())}\nv[2]: {0.67=* D(600.0*),~D(600.0)}^{do(B())}\n\nv[0]: \u2200x {power(\u03c3(1.0,log(\u03c3(1.0,x))),-1.0)=+ 0}^{D(x*)}\nv[1]: \u2200x {\u03c3(1.0,log(\u03c3(1.0,x)))=+ 0}^{S(x*)}\n\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#new_e1","title":"new_e1","text":"<p>Link to code</p> <pre><code>description:\nThe base class for all examples. It contains a series of views (v)\nfor operations and a conclusion (c).\nv[0]: \u2200x \u2203a \u2200y {P(x,a)Q(a,y)}\nv[1]: \u2203b \u2200z {P(b,z)}\n\nc (Conclusion): \u2203b \u2200x \u2200z \u2203a \u2200y {P(b,z)P(x,a)Q(a,y)}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#new_e2","title":"new_e2","text":"<p>Link to code</p> <pre><code>description:\nThe base class for all examples. It contains a series of views (v)\nfor operations and a conclusion (c).\nv[0]: \u2203a \u2200x {P(a)Q(x*)}\nv[1]: \u2200x \u2203b {Q(x*)R(b)}^{Q(x*)}\n\nc (Conclusion): \u2203a \u2200x \u2203b {P(a)Q(x*)R(b)}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#else_inquire","title":"else_inquire","text":"<p>Link to code</p> <pre><code>description:\nThe base class for all test types. Test types are mixins the define a test\ntype, but not the associated views.\nv[0]: \u2203a \u2200x {P(a)Q(x*)}\nv[1]: \u2200x \u2203b {Q(x*)R(b)}^{Q(x*)}\n\nc (Conclusion): \u2203a \u2200x {P(a)Q(x*)}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#else_merge","title":"else_merge","text":"<p>Link to code</p> <pre><code>description:\nThe base class for all test types. Test types are mixins the define a test\ntype, but not the associated views.\nv[0]: \u2203a \u2200x {P(a)Q(x*)}\nv[1]: \u2200x \u2203b {Q(x*)R(b)}^{Q(x*)}\n\nc (Conclusion): \u2203a \u2200x {P(a)Q(x*)}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#else_suppose","title":"else_suppose","text":"<p>Link to code</p> <pre><code>description:\nThe base class for all test types. Test types are mixins the define a test\ntype, but not the associated views.\nv[0]: \u2203a \u2200x {P(a)Q(x*)}\nv[1]: \u2200x \u2203b {Q(x*)R(b)}^{Q(x*)}\n\nc (Conclusion): \u2203a \u2200x {P(a)Q(x*)}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#else_uni_prod","title":"else_uni_prod","text":"<p>Link to code</p> <pre><code>description:\nThe base class for all test types. Test types are mixins the define a test\ntype, but not the associated views.\nv[0]: \u2203a \u2200x {P(a)Q(x*)}\nv[1]: \u2200x \u2203b {Q(x*)R(b)}^{Q(x*)}\n\nc (Conclusion): \u2203a \u2200x {P(a)Q(x*)}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#else_query","title":"else_query","text":"<p>Link to code</p> <pre><code>description:\nThe base class for all test types. Test types are mixins the define a test\ntype, but not the associated views.\nv[0]: \u2203a \u2200x {P(a)Q(x*)}\nv[1]: \u2200y \u2203a {Q(y*)R(a)}^{Q(y*)}\n\nc (Conclusion): \u2203a \u2200x {P(a)Q(x*)}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#else_which","title":"else_which","text":"<p>Link to code</p> <pre><code>description:\nThe base class for all test types. Test types are mixins the define a test\ntype, but not the associated views.\nv[0]: \u2203a \u2200x {P(a)Q(x*)}\nv[1]: \u2200y \u2203a {Q(y*)R(a)}^{Q(y*)}\n\nc (Conclusion): \u2203a \u2200x {P(a)Q(x*)}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#new_e5","title":"new_e5","text":"<p>Link to code</p> <pre><code>description:\nThe base class for all test types. Test types are mixins the define a test\ntype, but not the associated views.\nv[0]: \u2200x \u2200y \u2203a \u2203b \u2200z \u2203c {P(a*)P(b)P(c)P(y)P(z)Q(x*)}\nv[1]: \u2203d \u2203e \u2203f {P(d*)Q(e*)Q(f*)}\n\nc (Conclusion): \u2203d \u2203e \u2203f {P(d*)Q(e*)Q(f*)}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#new_e6_leibniz","title":"new_e6_leibniz","text":"<p>Link to code</p> <pre><code>description:\nThe base class for all test types. Test types are mixins the define a test\ntype, but not the associated views.\nv[0]: \u2203a \u2203b {==(a,b)P(f(a),a)~P(f(b),a)}\nv[1]: {}\n\nc (Conclusion): {}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#new_e7_aristotle","title":"new_e7_aristotle","text":"<p>Link to code</p> <pre><code>description:\nThe base class for all test types. Test types are mixins the define a test\ntype, but not the associated views.\nv[0]: \u2203a {~==(a,a)}\nv[1]: {}\n\nc (Conclusion): {}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#new_e8","title":"new_e8","text":"<p>Link to code</p> <pre><code>description:\nThe base class for all test types. Test types are mixins the define a test\ntype, but not the associated views.\nv[0]: {t()=+ A()}\nv[1]: {u()=* A()}\n\nc (Conclusion): {u()=* t()=+ A()}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#new_e9","title":"new_e9","text":"<p>Link to code</p> <pre><code>description:\nThe base class for all test types. Test types are mixins the define a test\ntype, but not the associated views.\nv[0]: \u2200x {P(x*)}\nv[1]: {P(j()*)}\n\nc (Conclusion): {0}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#new_e10","title":"new_e10","text":"<p>Link to code</p> <pre><code>description:\nThe base class for all test types. Test types are mixins the define a test\ntype, but not the associated views.\nv[0]: \u2200x {f(x)=* A(x*)}\nv[1]: \u2203e {f(e)=* A(e*)}\n\nc (Conclusion): \u2203e {f(e)=* A(e*)}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#new_e11","title":"new_e11","text":"<p>Link to code</p> <pre><code>description:\nThe base class for all test types. Test types are mixins the define a test\ntype, but not the associated views.\nv[0]: {f(12.0)=* A(12.0*)}\nv[1]: \u2203e {f(e)=* A(e*)}\n\nc (Conclusion): \u2203e {f(e)=* A(e*)}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#new_e12","title":"new_e12","text":"<p>Link to code</p> <pre><code>description:\nThe base class for all test types. Test types are mixins the define a test\ntype, but not the associated views.\nv[0]: {A()}\nv[1]: {}\n\nc (Conclusion): {A()}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#new_e13","title":"new_e13","text":"<p>Link to code</p> <pre><code>description:\nThe base class for all test types. Test types are mixins the define a test\ntype, but not the associated views.\nv[0]: {f(12.0)=* A(12.0*),B()}\n\nc (Conclusion): {}\nprob (Probability): \u2203e {A(e*)}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#new_e14","title":"new_e14","text":"<p>Link to code</p> <pre><code>description:\nThe base class for all test types. Test types are mixins the define a test\ntype, but not the associated views.\nv[0]: \u2200x \u2203y {A(f(x*))B(g(x*,y))}\nv[1]: {A(f(j()*))}\n\nc (Conclusion): \u2203y {A(f(j()*))B(g(j()*,y))}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#new_e15","title":"new_e15","text":"<p>Link to code</p> <pre><code>description:\nThe base class for all test types. Test types are mixins the define a test\ntype, but not the associated views.\nv[0]: \u2203k {==(Clark(),Superman())Defeats(k,Superman())}\nv[1]: {==(Clark()*,Superman())}\n\nc (Conclusion): \u2203k {==(Clark(),Clark())Defeats(k,Clark())}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#new_e16","title":"new_e16","text":"<p>Link to code</p> <pre><code>description:\nThe base class for all test types. Test types are mixins the define a test\ntype, but not the associated views.\nv[0]: \u2203k \u2203x {==(Clark(),x)Defeats(k,x)}\nv[1]: \u2203x {==(Clark()*,x)}\n\nc (Conclusion): \u2203k {==(Clark(),Clark())Defeats(k,Clark())}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#new_e17","title":"new_e17","text":"<p>Link to code</p> <pre><code>description:\nThe base class for all test types. Test types are mixins the define a test\ntype, but not the associated views.\nv[0]: \u2203k \u2203x {==(Clark(),x)do(Defeats(k,x))}\nv[1]: \u2203x {==(Clark()*,x)}\n\nc (Conclusion): \u2203k {==(Clark(),Clark())do(Defeats(k,Clark()))}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#new_e18","title":"new_e18","text":"<p>Link to code</p> <pre><code>description:\nThe base class for all test types. Test types are mixins the define a test\ntype, but not the associated views.\nv[0]: {m()=* A()}\nv[1]: {n()=* B()}\n\nc (Conclusion): {m()**n()=* A()B()}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#new_e19_first_atom_do_atom","title":"new_e19_first_atom_do_atom","text":"<p>Link to code</p> <pre><code>description:\nThe base class for all test types. Test types are mixins the define a test\ntype, but not the associated views.\nv[0]: \u2203k {==(Clark(),Superman())Defeats(k,Superman())}\nv[1]: {do(A())}\n\nc (Conclusion): \u2203k {==(Clark(),Superman())Defeats(k,Superman())}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#new_e20_nested_issue_in_pred","title":"new_e20_nested_issue_in_pred","text":"<p>Link to code</p> <pre><code>description:\nThe base class for all test types. Test types are mixins the define a test\ntype, but not the associated views.\nv[0]: \u2203k {==(Clark(),Superman())Defeats(k,Superman())}\nv[1]: {==(Clark(),f(Superman()*))}\n\nc (Conclusion): \u2203k {==(Clark(),Superman())Defeats(k,Superman())}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#new_e21_supp_is_something","title":"new_e21_supp_is_something","text":"<p>Link to code</p> <pre><code>description:\nThe base class for all test types. Test types are mixins the define a test\ntype, but not the associated views.\nv[0]: \u2203k {==(Clark(),Superman())Defeats(k,Superman())}\nv[1]: {==(Clark()*,Superman())}^{}\n\nc (Conclusion): \u2203k {==(Clark(),Superman())Defeats(k,Superman())}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#new_e22_restrict_dep_rel_is_not_other","title":"new_e22_restrict_dep_rel_is_not_other","text":"<p>Link to code</p> <pre><code>description:\nThe base class for all test types. Test types are mixins the define a test\ntype, but not the associated views.\nv[0]: \u2203k \u2203x {==(Clark(),x)do(Defeats(k,x))}\nv[1]: \u2203y {==(Clark()*,y)}\n\nc (Conclusion): \u2203k \u2203x {==(Clark(),x)do(Defeats(k,x))}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#answerpotential","title":"AnswerPotential","text":"<p>Link to code</p> <pre><code>description:\nThe base class for all examples. It contains a series of views (v)\nfor operations and a conclusion (c).\nv[0]: {1.0=* 2.0=+ A()B(),A()C(),0.4=* B()C()}\nv[1]: {A()}\nv[2]: {B()}\nv[3]: {C()}\nv[4]: {C()D()}\nv[5]: {C()~B()}\n\nc (Conclusion): {}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#uniproduct","title":"UniProduct","text":"<p>Link to code</p> <pre><code>description:\nThe base class for all test types. Test types are mixins the define a test\ntype, but not the associated views.\nv[0]: \u2200x \u2203a {E(x,a)P(x),~P(x*)}\nv[1]: {P(j()*)}\n\nc (Conclusion): \u2203a {E(j(),a)P(j()),~P(j()*)}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#querytest","title":"QueryTest","text":"<p>Link to code</p> <pre><code>description:\nFrom page 173\nv[0]: \u2200x {S(j()*)S(m()*)T(x,j()),S(j()*)S(m()*)T(x,m())}\nv[1]: \u2200x \u2203a {S(a*)T(x,a)}\n\nc (Conclusion): \u2200x \u2203a {S(a*)T(x,a)}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/case_index/#querytest2","title":"QueryTest2","text":"<p>Link to code</p> <pre><code>description:\nFrom page 173\nv[0]: \u2200x {S(j()*)S(m()*)T(x,j()),S(j()*)S(m()*)T(x,m())}\nv[1]: \u2203a \u2200x {S(a*)T(x,a)}\n\nc (Conclusion): \u2200x \u2203a {S(a*)T(x,a)}\ntest(verbose=False): Method used to test the example\n</code></pre>"},{"location":"reference/inference_index/","title":"Inference Index","text":"<p>Below you'll find all of the inference functions in pyetr.inference. You can use this page as an index of the inference methods.</p>"},{"location":"reference/inference_index/#basic_step","title":"<code>basic_step</code>","text":"<p>Link to code</p> <pre><code>Based Definition 4.47 p179-180\n\nG' = T[P\u2081[]\u1d30]^\u21bb[P\u2082]^\u21bb...[P\u2099]^\u21bb[\u22a5]\ua7f3\n\nArgs:\n    v (Sequence[View]): (P\u2081,..., P\u2099)\n    verbose (bool, optional): Enables verbose mode. Defaults to False.\n\nReturns:\n    View: G'\n</code></pre>"},{"location":"reference/inference_index/#default_inference_procedure","title":"<code>default_inference_procedure</code>","text":"<p>Link to code</p> <pre><code>Based Definition 4.47 p179-180\n\nG' = T[P\u2081[]\u1d30]^\u21bb[P\u2082]^\u21bb...[P\u2099]^\u21bb[\u22a5]\ua7f3\nG'' = G'[P\u2081[]\u1d30]\ua7f3...[P\u2099]\ua7f3\n\nArgs:\n    v (Sequence[View]): (P\u2081,..., P\u2099)\n    verbose (bool, optional): Enables verbose mode. Defaults to False.\n\nReturns:\n    View: G''\n</code></pre>"},{"location":"reference/inference_index/#default_procedure_does_it_follow","title":"<code>default_procedure_does_it_follow</code>","text":"<p>Link to code</p> <pre><code>Based Definition 4.47 p180\n\n(Sub-procedure for \"does \u0394^\u03a8_RI follow?\" tasks)\nG' = T[P\u2081[]\u1d30]^\u21bb[P\u2082]^\u21bb...[P\u2099]^\u21bb[\u22a5]\ua7f3\nG'' = G'[\u03a8^{0}_[R][I]]\u02e2[\u0394^\u03a8_RI]\ua7f4\n\nArgs:\n    v (Sequence[View]): (P\u2081,..., P\u2099)\n    target View: \u0394^\u03a8_RI\n    verbose (bool, optional): Enables verbose mode. Defaults to False.\n\nReturns:\n    bool: Report yes or no, note: Report G'' -&gt; yes\n</code></pre>"},{"location":"reference/inference_index/#default_procedure_what_is_prob","title":"<code>default_procedure_what_is_prob</code>","text":"<p>Link to code</p> <pre><code>Based on definition 5.20, p212\n\nG' = T[P\u2081]^\u21bb[]\u1d30[P\u2082]^\u21bb...[P\u2099]^\u21bb[\u22a5]\ua7f3\nG'' = G'[\u0394^\u03a8]\ua7f4\n\nIf G''[\u0394]^\ud835\udd3cP \u2208 [0,100]:\n    return G''\nElse\n    x = (100 - (\u03a3_\u03b3\u2208\u0393\u03a3\u300a\u03b1 \u2208 f(\u03b3) : \u03b1 \u2208 \u211d\u300b)) / #{\u03b3\u2208\u0393 : f(\u03b3) =\u300a\u300b}\n\n    where \u03b3\u2081...\u03b3\u2099 is {\u03b3 \u2208 \u0393 : f(\u03b3) =\u300a\u300b}\n    G'' = G'[{\u300ax\u300b.0 }^{\u03b3\u2081}]\u1d35...[{\u300ax\u300b.0 }^{\u03b3\u2099}]\u1d35[\u0394^\u03a8]\ua7f4\n\n    If G''[\u0394]^\ud835\udd3cP \u2208 [0,100]:\n        return G''\n    Else:\n        return \u22a5\nArgs:\n    v (Sequence[View]): (P\u2081,..., P\u2099)\n    prob_of (View): \u0394^\u03a8\n    verbose (bool, optional): Enables verbose mode. Defaults to False.\n\nReturns:\n    View: G''\n</code></pre>"},{"location":"reference/inference_index/#default_decision","title":"<code>default_decision</code>","text":"<p>Link to code</p> <pre><code>Based on Definition 6.7, p272\n\ndq[dq[CV]^\u21bb[\u22a5]\ua7f3[PR]^\u21bb]\n\nArgs:\n    dq (View): dq, Decision Question\n    cv (Iterable[View]): CV, Consequence Views\n    pr (Iterable[View]): PR, Priority Views\n    verbose (bool, optional): Enable verbose mode. Defaults to False.\n    absurd_states (Optional[list[State]], optional): Any additional absurd states in the system. Defaults to None.\n\nReturns:\n    View: The resultant view.\n</code></pre>"},{"location":"reference/overview/","title":"Reference","text":"<p>The following collection of pages were automatically generated based on the code. They describe each of the available cases, operations and inference methods. This is a subset of those available in the code, but we've only excluded those that we felt wouldn't be useful to a user of PyETR.</p>"},{"location":"reference/utils_index/","title":"Utilities Index","text":"<p>Below you'll find all of the utilities in pyetr.utils. You can use this page as an index of the available utilities.</p>"},{"location":"reference/utils_index/#views_to_smt_lib","title":"<code>views_to_smt_lib</code>","text":"<p>Link to code</p> <pre><code>Convert multiple views into a single smt lib string.\n\nArgs:\n    views (list[View]): A list of views to convert.\n    env (typing.Optional[Environment], optional): The pysmt environment to embed\n        parsed variables. If None will use a fresh environment to avoid clashes.\n        Defaults to None.\n\nReturns:\n    str: The smt lib string containing multiple views.\n</code></pre>"},{"location":"reference/utils_index/#smt_lib_to_views","title":"<code>smt_lib_to_views</code>","text":"<p>Link to code</p> <pre><code>Convert one smt lib string containing multiple Views into a series of Views.\n\nArgs:\n    smt_lib (str): The smt lib string\n    custom_functions (Optional[list[NumFunc  |  Function]], optional): Custom functions used in the\n        string. It assumes the name of the function is that used in the string. Useful\n        for using func callers. Defaults to None.\n\nReturns:\n    list[View]: The list of views found in the smt lib string.\n</code></pre>"},{"location":"reference/view_methods/","title":"View Methods Index","text":"<p>Below you'll find all of the methods of View, including associated operations and ways of creating them.</p>"},{"location":"reference/view_methods/#view-operations","title":"View Operations","text":""},{"location":"reference/view_methods/#product","title":"<code>product</code>","text":"<p>Link to code</p> <pre><code>Based on definition 5.15, p208\n\n\u0393^\u03b8_fRI \u2a02\u1d40 \u0394^{\u03a8}_gSJ = (\u0393_f \u2a02 \u0394^{\u03a8}_g)^\u03b8_(T\u22c8R)\u22c8(T\u22c8S),I\u222aJ\n\nwhere \u0393_f \u2a02 \u0394^{\u03a8}_g = P + \u03a3_\u03b3\u2208(\u0393\uff3cP) \u03a3_\u03b4\u2208\u0394 {f(\u03b3) x g(\u03b4)).(\u03b3\u222a\u03b4)}\nand P = {f(\u03b3).\u03b3\u2208\u0393 |\u00ac\u2203\u03c8 \u2208 \u03a8.\u03c8\u2286\u03b3}\n\nArgs:\n    self (View): \u0393^\u03b8_fRI\n    view (View): \u0394^{\u03a8}_gSJ\n    inherited_dependencies (Optional[DependencyRelation], optional): T. Defaults to an empty\n        dependency relation.\n\nReturns:\n    View: The result of the product calculation.\n</code></pre>"},{"location":"reference/view_methods/#sum","title":"<code>sum</code>","text":"<p>Link to code</p> <pre><code>Based on definition 5.14, p208\n\n\u0393^\u03b8_fRI \u2295\u1d40 \u0394^{0}_gSJ = (\u0393_f + \u0394_g)^\u03b8_(T\u22c8R)\u22c8(T\u22c8S),I\u222aJ\n\nwhere (\u0393_f + \u0394_g) = (\u0393 \u222a \u0394)_h, where h(\u03b3) = f(\u03b3) + g(\u03b3)\n\nArgs:\n    self (View): \u0393^\u03b8_fRI\n    view (View): \u0394^{0}_gSJ\n    inherited_dependencies (Optional[DependencyRelation], optional): T. Defaults to an empty\n        dependency relation.\n\nReturns:\n    View: The result of the sum calculation\n</code></pre>"},{"location":"reference/view_methods/#update","title":"<code>update</code>","text":"<p>Link to code</p> <pre><code>Based on Definition 4.34, p163\n\n\u0393^\u0398_fRI[D]^\u21bb = \u0393^\u0398_fRI[D]\u1d41[D]\u1d31[D]\u1d2c[D]\u1d39\n\nArgs:\n    self (View): \u0393^\u0398_fRI\n    view (View): D\n    verbose (bool, optional): Enables verbose mode. Defaults to False.\n\nReturns:\n    View: The updated view.\n</code></pre>"},{"location":"reference/view_methods/#answer","title":"<code>answer</code>","text":"<p>Link to code</p> <pre><code>Based on definition 5.13, p206\n\n\u0393^\u03b8_fRI[\u0394^{0}_gSJ]^A = \u0393^\u03b8_fRI[\u0394^{0}_gSJ]^\ud835\udd3cA[\u0394^{0}_gSJ]^\ud835\udcd0A\n\nArgs:\n    self (View): \u0393^\u03b8_fRI\n    other (View): \u0394^{0}_gSJ\n    verbose (bool, optional): enables verbose mode\n\nReturns:\n    View: The result of the answer calculation\n</code></pre>"},{"location":"reference/view_methods/#negation","title":"<code>negation</code>","text":"<p>Link to code</p> <pre><code>Based on definition 5.16, p210\n\n[\u0393^\u0398_fRI]\u1db0 = (\u0398 \u2a02 [\u0393]\u1db0)^{0}_[R]\u1db0[I]\u1db0\n\nArgs:\n    self (View): \u0393^\u0398_fRI\n    verbose (bool, optional): enable verbose mode. Defaults to False.\n\nReturns:\n    View: The negated view.\n</code></pre>"},{"location":"reference/view_methods/#merge","title":"<code>merge</code>","text":"<p>Link to code</p> <pre><code>Based on Definition 5.26, p221\n\n\u0393^\u0398_fRI[\u0394^\u03a8_gSJ]\u1d39 = \u2295^R\u22c8S_\u03b3\u2208\u0393 {f(\u03b3).\u03b3}|^\u0398_RI \u2a02^R\u22c8S \u0394^\u03a8_gSJ \u2a02^R\u22c8S (\u2b59^R\u22c8S_&lt;t,u&gt;\u2208M'ij(\u03b3) Sub^R\u22c8S_&lt;t,u&gt;(\u0394^{0}_gSJ))\n\nArgs:\n    self (View): \u0393^\u0398_fRI\n    view (View): \u0394^\u03a8_gSJ\n    verbose (bool, optional): enable verbose mode. Defaults to False.\n\nReturns:\n    View: Returns the merged view.\n</code></pre>"},{"location":"reference/view_methods/#division","title":"<code>division</code>","text":"<p>Link to code</p> <pre><code>Based on definition 4.38, p168\n\nIf \u2200\u03b4_\u2208\u0394 \u2203\u03c8_\u2208\u03a8 \u2203\u03b3\u2208\u0393 (\u03b4 \u2286 \u03b3 \u2227 \u03c8 \u2286 \u03b3):\n\n\u0393^\u0398_RI \u2298 \u0394^\u03a8_SJ = {\u03b3 \u2298_\u0393 \u0394^\u03a8 : \u03b3\u2208\u0393}^\u0398_[R][I]\n\nArgs:\n    self (View): \u0393^\u0398_fRI\n    view (View): \u0394^\u03a8_SJ\n    verbose (bool, optional): Enables verbose mode. Defaults to False.\n\nReturns:\n    View: The divided view.\n</code></pre>"},{"location":"reference/view_methods/#factor","title":"<code>factor</code>","text":"<p>Link to code</p> <pre><code>Based on definition 5.17 p210 (contradiction)\nBased on definition 5.35 p233 (identity)\nBased on definition 5.32 p232 (central case)\n\nContradiction: \u0393^\u0398_fRI[\u22a5]\ua7f3 = {\u03b3\u2208\u0393 : \u00ac\u2203\u03ba \u2208 \ud835\udd42.\u03ba \u2286 \u03b3}^\u0398_fRI\nIdentity: \u0393^\u0398_fRI[{w.t\u2081==t\u2082}^{0}_gSJ]\ua7f3 = {\u03b3 \u2208 \u0393 : t\u2081==t\u2082 \u2209 \u03b3}_f + \u03a3_\u03b3\u2208\u0393 s.t.t\u2081==t\u2082\u2208\u03b3 {(f(\u03b3)[t\u2081/t\u2082]).(\u03b3[t\u2081/t\u2082])}^\u0398_RI\nCentral: \u0393^\u0398_fRI[\u0394^\u03a8_gSJ]\ua7f3 = \u03a3_\u03b3\u2208\u0393 {f(\u03b3).\u03b3[\u0394^\u03a8]\ua7f3}\n\nArgs:\n    self (View): \u0393^\u0398_fRI\n    other (View): \u22a5 | {w.t\u2081==t\u2082}^{0}_gSJ | \u0394^\u03a8_gSJ\n    verbose (bool, optional): Enables verbose mode. Defaults to False.\n    absurd_states (Optional[list[State]], optional): Manual input of primitive absurd states. Defaults to None.\n\nReturns:\n    View: The factored view.\n</code></pre>"},{"location":"reference/view_methods/#depose","title":"<code>depose</code>","text":"<p>Link to code</p> <pre><code>Based on definition 5.23\n\n\u0393^\u0398_fRI[]\u1d30 = (\u0393_f + [\u0398]\u1db0)^{0}_R[I]\u1db0\n\nArgs:\n    verbose (bool, optional): Enables verbose mode. Defaults to False.\n\nReturns:\n    View: The deposed view.\n</code></pre>"},{"location":"reference/view_methods/#inquire","title":"<code>inquire</code>","text":"<p>Link to code</p> <pre><code>Based on definition 5.18, p210\n\n\nIf A(\u0393\u222a\u0398) \u2229 A(\u0394\u222a\u03a8) = \u2205 and A(\u0394) \u2229 A(\u03a8) = \u2205\n    O Case: \u0393^\u0398_fRI[\u0394^\u03a8_gSJ]\u1d35 = (\u0393^\u0398_fRI \u2a02 (\u0394^\u03a8_gSJ \u2295\u02e2({0}^\u03a8_SJ \u2a02 ([\u0394^{0}_gSJ]\u1db0)^nov(A(\u0394)))))[\u22a5]\ua7f3\n\nElse if A(\u0394\u222a\u03a8) \u2286 A(\u0393\u222a\u0398) and S = [R]_\u0393\u222a\u0398\n    I Case: \u0393^\u0398_fRI[\u0394^\u03a8_gSJ]\u1d35 = (\u0393^\u0398_fRI \u2a02\u1d3f (\u0394^\u03a8_gSJ \u2295\u1d3f ([\u0394_g]\u1db0|^\u03a8_SJ)))[\u22a5]\ua7f3\n\nElse:\n    \u0393^\u0398_fRI[\u0394^\u03a8_gSJ]\u1d35 = \u0393^\u0398_fRI\nArgs:\n    self (View): \u0393^\u0398_fRI\n    other (View): \u0394^\u03a8_gSJ\n    verbose (bool, optional): Enables verbose mode. Defaults to False.\n\nReturns:\n    View: The resultant inquired view.\n</code></pre>"},{"location":"reference/view_methods/#suppose","title":"<code>suppose</code>","text":"<p>Link to code</p> <pre><code>Based on definition 5.22, p219\n\nIf A(\u0393\u222a\u0398) \u2229 A(\u0394\u222a\u03a8) = \u2205 \u2227 \u0394^\u03a8_gSJ = \u0394^\u03a8_SJ\n    O Case: \u0393^\u0398_fRI[\u0394^\u03a8_gSJ]\u02e2 = \u0393^\u0398'_[R\u22c8R'][I\u222aI'] [\u0394^\u03a8_gSJ]\u1d41[\u0394^\u03a8_gSJ]\u1d31[\u0394^\u03a8_gSJ]\u1d2c[\u0394^\u03a8_gSJ]\u1d39\n\n    where: \u0398'^{0}_R'I' = \u0398^{0}_RI \u2a02 Nov(\u0394^\u03a8_[S]\u1db0J []\u1d30)\n\nElse if A(\u0394) \u2286 A(\u0393\u222a\u0398), [R]_\u0394 = S, and \u0394^\u03a8_gSJ = \u0394^\u03a8_SJ and \u03a8 = {0}\n    I Case: \u0393^\u0398_fRI[\u0394^{0}_gSJ]\u02e2 = \u0393^(\u0398\u2a02\u0394)_fRI[\u0394^{0}_gSJ]\u1d41[\u0394^{0}_gSJ]\u1d31[\u0394^{0}_gSJ]\u1d2c[\u0394^{0}_gSJ]\u1d39\n\nElse:\n    \u0393^\u0398_fRI[\u0394^\u03a8_gSJ]\u02e2 = \u0393^\u0398_fRI\n\nArgs:\n    self: (View): \u0393^\u0398_fRI\n    other (View): \u0394^\u03a8_gSJ\n    verbose (bool, optional): Enables verbose mode. Defaults to False.\n\nReturns:\n    View: The resultant view.\n</code></pre>"},{"location":"reference/view_methods/#query","title":"<code>query</code>","text":"<p>Link to code</p> <pre><code>Based on definition 5.19, p210\nIf U_S \u2286 U_R:\n    \u0393^\u0398_fRI[\u0394^\u03a8_gSJ]\ua7f4 = H + \u03a3_\u03b3\u2208\u0393 \u03a3_\u03b4\u2208\u0394_s.t.\u03a6(\u03b3, \u03b4) {w_(\u03b3,\u03b4).\u03b4}^\u0398_R\u22c8&lt;U_R,E_S\uff3cE_R,D_S'&gt;,I\u222aJ\nElse:\n    \u0393^\u0398_fRI[\u0394^\u03a8_gSJ]\ua7f4 = \u0393^\u0398_fRI\n</code></pre>"},{"location":"reference/view_methods/#which","title":"<code>which</code>","text":"<p>Link to code</p> <pre><code>Based on definition 5.33, p232\n\n\u0393^\u0398_fRI[\u0394^\u03a8_gSJ]\u1d42 = H + \u03a3_\u03b3\u2208\u0393\u300a\u03c9.\u03be : \u039e(\u03b3,\u03c9.\u03be)\u300b|^\u0398_RI\n\n\u039e(\u03b3,\u03c9.\u03be) = \u2203\u03c8_\u2208\u03a8 \u2203\u03b4_\u2208\u0394 \u2203n\u22650 \u2203&lt;t\u2081,e\u2081&gt;,...,&lt;t\u2099,e\u2099&gt;\u2208M'ij (\u2200i,j.(e_i=e_j -&gt; i=j)) \u2227 (\u03be\u222a\u03c8 \u2286 \u03b3 \u2227 \u03c9.\u03be = (g(\u03b4).\u03b4)[t\u2081/e\u2081,...,t\u2099/e\u2099])\n\nArgs:\n    self (View): \u0393^\u0398_fRI\n    other (View): \u0394^\u03a8_gSJ\n    verbose (bool, optional): Enables verbose mode. Defaults to False.\n\nReturns:\n    View: The resultant view.\n</code></pre>"},{"location":"reference/view_methods/#universal_product","title":"<code>universal_product</code>","text":"<p>Link to code</p> <pre><code>Based on Definition 5.28, p223\n\n\u0393^\u0398_fRI[D]\u1d41 = {0}^\u0398_RI \u2a02^R\u22c8S (\u2a02^R\u22c8S_&lt;u,t&gt;\u2208M'ij Sub^R\u22c8S_&lt;t,u&gt; (\u0393^{0}_fRI))\n</code></pre>"},{"location":"reference/view_methods/#atomic_answer","title":"<code>atomic_answer</code>","text":"<p>Link to code</p> <pre><code>Based on definition 5.12, p206\n\n\u0393^\u03b8_fRI[\u0394^{0}_gSJ]^\ud835\udcd0A = argmax_\u03b3\u2208\u0393(\u0394[{{p} : p \u2208 \u03b3}]^\ud835\udcd0P)_f |^\u03b8_RI\n\nArgs:\n    self (View): \u0393^\u03b8_fRI\n    other (View): \u0394^{0}_gSJ\n    verbose (bool, optional): enables verbose mode\n\nReturns:\n    View: The result of the atomic answer calculation\n</code></pre>"},{"location":"reference/view_methods/#equilibrium_answer","title":"<code>equilibrium_answer</code>","text":"<p>Link to code</p> <pre><code>Based on definition 5.10, p205\n\n\u0393^\u03b8_fRI[\u0394^{0}_gSJ]^\ud835\udd3cA\n\nArgs:\n    self (View): \u0393^\u03b8_fRI\n    other (View): \u0394^{0}_gSJ\n    verbose (bool, optional): enables verbose mode\n\nReturns:\n    View: The result of the equilibrium answer calculation\n</code></pre>"},{"location":"reference/view_methods/#existential_sum","title":"<code>existential_sum</code>","text":"<p>Link to code</p> <pre><code>Based on Definition 5.34, p233\n\n\u0393^\u0398_fRI[\u0394^{0}_gSJ]\u1d31 = \u0393^\u0398_fRI \u2295^R\u22c8S (\n    \u2295^R\u22c8S_&lt;e,t&gt;\u2208M'ij Sub^R\u22c8S_&lt;t,e&gt; (BIG_UNION(e)^\u0398_SJ)\n)\n</code></pre>"},{"location":"reference/view_methods/#parsing","title":"Parsing","text":""},{"location":"reference/view_methods/#from_str","title":"<code>from_str</code>","text":"<p>Link to code</p> <pre><code>Parses from view string form to view form.\n\nArgs:\n    s (str): view string\n    custom_functions (list[NumFunc | Function] | None, optional): Custom functions used in the\n        string. It assumes the name of the function is that used in the string. Useful\n        for using func callers. Defaults to None.\n\nReturns:\n    View: The output view\n</code></pre>"},{"location":"reference/view_methods/#to_str","title":"<code>to_str</code>","text":"<p>Link to code</p> <pre><code>Parses from View form to view string form\n\nArgs:\n    v (View): The view to convert to string\n\nReturns:\n    str: The view string\n</code></pre>"},{"location":"reference/view_methods/#from_fol","title":"<code>from_fol</code>","text":"<p>Link to code</p> <pre><code>Parses from first order logic string form to View form.\n\nArgs:\n    s (str): A first order logic string\n    custom_functions (list[NumFunc | Function] | None, optional): Custom functions used in the\n        string. It assumes the name of the function is that used in the string. Useful\n        for using func callers. Defaults to None.\nReturns:\n    View: The parsed view\n</code></pre>"},{"location":"reference/view_methods/#to_fol","title":"<code>to_fol</code>","text":"<p>Link to code</p> <pre><code>Parses from View form to first order logic string form.\n\nArgs:\n    v (View): The View object\n\nReturns:\n    str: The first order logic string form.\n</code></pre>"},{"location":"reference/view_methods/#from_json","title":"<code>from_json</code>","text":"<p>Link to code</p> <pre><code>Parses from json form to View form\n\nArgs:\n    s (str): The json string\n\nReturns:\n    View: The parsed view\n</code></pre>"},{"location":"reference/view_methods/#to_json","title":"<code>to_json</code>","text":"<p>Link to code</p> <pre><code>Parses from View form to json form\n\nArgs:\n    v (View): The input view\n\nReturns:\n    str: The output json\n</code></pre>"},{"location":"reference/view_methods/#from_smt","title":"<code>from_smt</code>","text":"<p>Link to code</p> <pre><code>Parses from first order logic pysmt form to View form.\n\nArgs:\n    fnode (FNode): The pysmt object\n    custom_functions (list[NumFunc | Function] | None, optional): Custom functions used in the\n        string. It assumes the name of the function is that used in the string. Useful\n        for using func callers. Defaults to None.\nReturns:\n    Self: The parsed view\n</code></pre>"},{"location":"reference/view_methods/#to_smt","title":"<code>to_smt</code>","text":"<p>Link to code</p> <pre><code>Parses from View form to first order logic pysmt form.\n\nArgs:\n    env (Optional[Environment], optional): The pysmt environment to embed\n        parsed variables. If None will use a fresh environment to avoid clashes.\n        Defaults to None.\n\nReturns:\n    FNode: The parsed pysmt object\n</code></pre>"},{"location":"reference/view_methods/#from_smt_lib","title":"<code>from_smt_lib</code>","text":"<p>Link to code</p> <pre><code>Parses from SMT Lib form to View form.\n\nArgs:\n    smt_lib (str): The input string in SMT Lib structure\n    custom_functions (list[NumFunc  |  Function] | None, optional): Custom functions used in the\n        string. It assumes the name of the function is that used in the string. Useful\n        for using func callers. Defaults to None.\n    env (Optional[Environment], optional): The pysmt environment to embed\n        parsed variables. If None will use a fresh environment to avoid clashes.\n        Defaults to None.\n\nReturns:\n    Self: The parsed view\n</code></pre>"},{"location":"reference/view_methods/#to_smt_lib","title":"<code>to_smt_lib</code>","text":"<p>Link to code</p> <pre><code>Parses from View form to SMT Lib form.\n\n\nArgs:\n    env (Optional[Environment], optional):  The pysmt environment to embed\n        parsed variables. If None will use a fresh environment to avoid clashes.\n        Defaults to None.\n\nReturns:\n    str: The view string in SMT Lib structure\n</code></pre>"},{"location":"reference/view_methods/#to_english","title":"<code>to_english</code>","text":"<p>Link to code</p> <pre><code>Parses from View form to english string form.\n\nArgs:\n    v (View): The View object\n    name_mappings (Optional[dict[str,str]]): Maps strings in variables, predicates etc to\n        replacements strings\n\nReturns:\n    str: The english string form.\n</code></pre>"},{"location":"reference/view_methods/#other","title":"Other","text":""},{"location":"reference/view_methods/#replace-overload1","title":"<code>replace (overload1)</code>","text":"<p>Link to code</p> <pre><code>Searches for the string name of old item and replaces all instances with new item.\n\nArgs:\n    old_item (str): The search string\n    new_item (str): The replacement string\n\nReturns:\n    View: The new view with the replacements made\n</code></pre>"},{"location":"reference/view_methods/#replace-overload2","title":"<code>replace (overload2)</code>","text":"<p>Link to code</p> <pre><code>Searches for the arbitrary object and replaces all instances with new item.\n\nArgs:\n    old_item (ArbitraryObject): The search object\n    new_item (ArbitraryObject): The replacement object\n\nReturns:\n    View: The new view with the replacements made\n</code></pre>"},{"location":"reference/view_methods/#replace-overload3","title":"<code>replace (overload3)</code>","text":"<p>Link to code</p> <pre><code>Searches for the function and replaces all instances with new item.\n\nArgs:\n    old_item (Function): The function to search for\n    new_item (Function): The function to replace with\n\nReturns:\n    View: The new view with the replacements made\n</code></pre>"},{"location":"reference/view_methods/#replace-overload4","title":"<code>replace (overload4)</code>","text":"<p>Link to code</p> <pre><code>Searches for the predicate and replaces all instances with new item.\n\nArgs:\n    old_item (Predicate): The predicate to search for\n    new_item (Predicate): The predicate to replace with\n\nReturns:\n    View: The new view with the replacements made\n</code></pre>"},{"location":"theory/differences/","title":"Differences with Reason &amp; Inquiry","text":"<p>On this page we list the most significant differences between the Chapter 6 system of Reason &amp; Inquiry and the system implemented by PyETR.</p>"},{"location":"theory/differences/#notation","title":"Notation","text":"<p>There are a few superficial notational differences worth summarizing.</p> <ul> <li>Dependency relations in PyETR are mainly notated with quantifier strings, whereas the notation in R&amp;I is more analogous to the <code>.base</code> representation of a view.</li> <li>Issues in PyETR are notated with an asterisk <code>*</code>, instead of a circumflex as in R&amp;I.</li> <li>Names of constants in PyETR normally need to be input with empty brackets, e.g. <code>John()</code> and rather than <code>John</code>. Similarly, primitive propositions (nullary predicates) need empty brackets too, e.g. <code>IsRaining()</code> rather than <code>IsRaining</code>.</li> <li>The special \\(=\\) binary predicate symbol from R&amp;I Chapter 4 onwards is notated with a double equal sign <code>==</code>. It appears as prefix, just like any other predicate, e.g. <code>==(Clark(),Superman())</code>.</li> <li>The notation for multisets is a bit different, see View construction for weights and just below for \\(\\sigma\\).</li> <li>The special \\(\\overline\\times\\) binary function symbol from R&amp;I Chapter 5 onwards is notated with a double asterisk <code>**</code> in PyETR. It can be used either prefix or infix, e.g. both <code>**(2,x)</code> and <code>2 ** x</code> are valid and denote the same term. See also Collapsing functions.</li> <li>The special \\(\\sigma\\) function symbol from R&amp;I Chapter 5 onwards is notated either <code>++</code> (for convenient typing) or <code>\u03c3</code>. It is used as a prefix on a comma-separated list of arguments inside round brackets, e.g. <code>++(1,1,x)</code>. Any number of items can appear in the argument list, which is interpreted as a multiset. See also Collapsing functions.</li> <li>Real numbers were introduced as terms in R&amp;I Chapter 5. In PyETR, terms that should be real numbers are inferred automatically from any numbers present in the string (see here).</li> </ul>"},{"location":"theory/differences/#commitments","title":"Commitments","text":"<p>PyETR does not currently work with any notion of commitment. Some of the operations and procedures in R&amp;I were directed by a set of commitments, i.e. a background set of views held like beliefs, in PyETR we currently rely on the users to implement their own 'set of commitments'. For most purposes this is not an issue, and it has almost no effect on the case studies.</p> <p>It does have a small significance for novelization, which is performed at a more local level than was envisaged in R&amp;I. For example, in R&amp;I, the second argument of an update was expected to be use arbitrary objects which are novel for the entire set of arbitrary objects seen so far, whereas in PyETR Update is hard-coded to perform novelization by itself, and only relative to its first argument. The PyETR behaviour should be more convenient.</p>"},{"location":"theory/differences/#collapsing-functions","title":"Collapsing functions","text":"<p>In R&amp;I all function symbols were considered to be completely static. While certain operations formed new term expressions out of binary multiplication \\(\\overline\\times\\) and multiset-sum \\(\\sigma\\), these expressions were considered to be left unevaluated. At the points where a final value was required, it was assumed that some procedure was given for evaluating the term, with the exact nature left open.</p> <p>In PyETR, functional terms can be more dynamic. Two built-in function symbols, <code>**</code> and <code>++</code>/<code>\u03c3</code>, will attempt to simplify themselves as soon as they are instantiated. For example, the term <code>2 ** 3</code> is automatically replaced with <code>6</code> and the term <code>++(1,1,3)</code> is automatically replaced with <code>5</code>.</p> <p>The simplification for <code>**</code> and <code>++</code> only happens when both/all arguments are real numbers. Note that this happens at any point where a new view is created, not only at parse time. Suppose a view contains a term such as <code>x ** 3</code> where <code>x</code> is an arbitrary object. Then, if in the process of computing an operation a real number term is substituted for <code>x</code>, the output view will have the corresponding substitution instances of <code>x ** 3</code> simplified already.</p> <p>The advantage of the approach taken in PyETR is that operations such as Answer can operate without any intervention to simplify arithmetic expressions. The main caveat is that sometimes issue items can unexpectedly disappear. For example, the view <code>{ A(2 ** (3*)) }</code> is parsed equally to <code>{ A(6) }</code>, despite the attempt to include a non-trivial issue structure in the first view. The reason is that, after simplifying <code>2 ** 3</code> to <code>6</code>, there is no longer identifiably an atom <code>A(2 ** ?)</code> with <code>3</code> in <code>?</code>-position. This does not affect any of the case studies from R&amp;I.</p>"},{"location":"theory/differences/#do-atoms-and-issue-structures","title":"Do atoms and issue structures","text":"<p>In R&amp;I Chapter 6, the interaction of do atoms and issue structures was left imprecise. In PyETR, the issue context of a term only extends to the first atom containing it, and does not include a <code>do</code>. For example, consider parsing the string <code>\u2200x {do(A(x*)B())}</code>. <pre><code>from pyetr import View\nv = View.from_str(\"\u2200x {do(A(x*)B())}\")\nprint(v.base) # {do(A()B(x))}^{0} issues={(x,A(?))} U={x} E={}\n</code></pre> Note that resulting issue structure contains <code>(x,A(?))</code>, rather than <code>(x,do(A(?)B()))</code>.</p>"},{"location":"theory/systems/","title":"Systems from Reason &amp; Inquiry","text":"<p>On this page we recap the structure of the book Reason &amp; Inquiry and explain how to relate its contents to PyETR.</p>"},{"location":"theory/systems/#four-versions-of-the-etr-system","title":"Four versions of the ETR system","text":"<p>Reason &amp; Inquiry incrementally builds up erotic theory vertically through successive degrees of expressive power in what views can represent.</p> <ul> <li>Chapter 2: introduces the most basic case: views that can express the contents of sentences in sentential logic.</li> <li>Chapter 4: adds terms and arbitrary objects. With these additions, views can now express the kinds of contents that first-order logic can talk about. In Stuart Russell\u2019s slightly humorous phrase, this gives us the power \"to represent the most important aspects of the real word, such as action, space, time, thoughts, and shopping\".</li> <li>Chapter 5: introduces weighted states, that allow us to express reasoning under uncertainty.</li> <li>Chapter 6: introduces states with dual weights (multiplicative and additive) as well as do-atoms, allowing views to capture decision-making (under uncertainty).</li> </ul> <p>The DNA of the reasoning operations of the erotetic theory stays the same throughout, in that subsequent increases of expressive power strictly generalise the weaker systems. In each level of expressive power do we get a version of the following result (informally stated here, but defined and proved formally in the book): </p> <p>If the judgment of the reasoner is in erotetic equilibrium (that is, the judgment is still available regardless of how many further questions are taken on board), then the judgment satisfies classical constraints on rational inference. For first-order and sentential logic equivalent expressive power, this means classical validity. For reasoning under uncertainty, this means Bayesian coherence. For decision making, this means rational choice. The book takes the view that it is not always a rational requirement to satisfy these standards.</p> <p>PyETR implements the erotetic theory through Chapter 6, with a few modifications. Since all of the other systems can be translated into the Chapter 6 one, this allows us to use PyETR to study examples written for any of the systems in R&amp;I. In practice, this means there is occasionally a little notational overhead, most notable in View Construction.</p>"},{"location":"theory/systems/#translations-between-systems","title":"Translations between systems","text":"<p>Views in more primitive systems can be translated into the later systems.</p> <ul> <li> <p>Chapter 2 -&gt; Chapter 4: Treat Chapter 2 atoms as Chapter 4 atoms formed from nullary predicates, and leave the dependency relation and issue structure empty.</p> </li> <li> <p>Chapter 4 -&gt; Chapter 5: Give each state in the stage the empty multiset \\(\\llangle \\rrangle\\) as its weight.</p> </li> <li> <p>Chapter 5 -&gt; Chapter 6: The existing weight of a state becomes its multiplicative weight and its additive weight becomes the empty multiset \\(\\llangle \\rrangle\\).</p> </li> </ul> <p>These 'upwards' translations are designed to commute with view operations. Concretely, if we write the translation from Chapter \\(m\\) views to Chapter \\(n\\) views as \\(\\uparrow_m^n\\), then for any operation \\(O\\) defined in Chapter \\(m\\), firstly Chapter \\(n\\) has an operation with the same name for example, and secondly if \\(G\\) &amp; \\(D\\) are Chapter \\(m\\) views then the following equation holds.</p> \\[ \\uparrow_m^n(G[D]^O) = (\\uparrow_m^n G)[\\uparrow_m^n D]^O \\] <p>See Theorem B.44 in R&amp;I for the case of \\(\\uparrow_4^5\\).</p> <p>It sometimes seems reasonable to consider 'downwards' translations as well. The step from 5 to 4 works well: we simply drop the weights from the states. We can go from 6 to 5 by forgetting the additive weights and possibly removing any do-atoms. There does not seem to be any feasible way to go from 4 to 2 that preserves a reasonable amount of content. Moreover, downwards translates should not be expected to commute with reasoning operations, see Theorem B.45 in R&amp;I.</p>"},{"location":"usage/direct_decision_example/","title":"Direct Decision","text":"<p>We'll be using example 90 (part i) from page 249 of the book.</p> <pre><code>Example 90, p249, p273\n\nImagine that you have been saving some extra money on the side to make some purchases,\nand on your most recent visit to the video store you come across a special sale of a new\nvideo. This video is one with your favourite actor or actress, and your favourite type of\nmovie (such as a comedy, drama, thriller etc.). This particular video that you are considering\nis one you have been thinking about buying a long time. It is a available at a special sale price\nof $14.99. What would you do in this situation?\n</code></pre> <p>Let's go through what this case does if we were to do the operation manually.</p>"},{"location":"usage/direct_decision_example/#step-1-import-package-and-operation","title":"Step 1: Import package and operation","text":"<pre><code>from pyetr import View\nfrom pyetr.inference import default_decision\n</code></pre>"},{"location":"usage/direct_decision_example/#step-2-define-the-views-for-the-operation","title":"Step 2: Define the views for the operation","text":"<p>First we must define the view representing the decision to be made, in this case this view has two states, buying the video or not buying the video: <pre><code>v = View.from_str(\"{do(Buy(Video()*)),~do(Buy(Video()))}\")\n</code></pre> Next we define the view representing the consequence of making the decision, in this case \"For all x, fun is the result if buy x\": <pre><code>cv = View.from_str(\"Ax {Fun()}^{do(Buy(x*))}\")\n</code></pre> The last view to define represents the priority views. This view simply applies an additive weight to \"Fun\", such that \"Fun\" becomes a priority: <pre><code>pr = View.from_str(\"{1=+ 0} ^ {Fun()}\")\n</code></pre></p>"},{"location":"usage/direct_decision_example/#step-3-calculate-the-decision","title":"Step 3: Calculate the decision","text":"<p>Finally, we put all of these views into the decision calculation: <pre><code>result = default_decision(dq=v, cv=[cv], pr=[pr])\nprint(result) # {do(Buy(Video()*))}\n</code></pre></p>"},{"location":"usage/direct_decision_example/#full-example","title":"Full Example","text":"<pre><code>from pyetr import View\nfrom pyetr.inference import default_decision\n\nv = View.from_str(\"{do(Buy(Video()*)),~do(Buy(Video()))}\")\ncv = View.from_str(\"Ax {Fun()}^{do(Buy(x*))}\")\npr = View.from_str(\"{1=+ 0} ^ {Fun()}\")\n\nresult = default_decision(dq=v, cv=[cv], pr=[pr])\nprint(result) # {do(Buy(Video()*))}\n</code></pre>"},{"location":"usage/first_steps/","title":"First Steps","text":""},{"location":"usage/first_steps/#intro","title":"Intro","text":"<p>This example is based on Example 17 from the book.</p> <p>Example 17, p83</p> <p>P1 There is a king in the hand and there is not an ace in the hand, or else there is an ace in the hand and there is not a king in the hand.</p> <p>P2 There is a king in the hand.</p> <p>C There isn't an ace in the hand.</p> <p>For the full example see here</p>"},{"location":"usage/first_steps/#step-1-import-package","title":"Step 1: Import package","text":"<p><pre><code>from pyetr import View\nfrom pyetr.inference import default_inference_procedure\n</code></pre> Import the parsing object</p>"},{"location":"usage/first_steps/#step-2-create-object-form-of-views","title":"Step 2: Create object form of views","text":"<p>P1 There is a king in the hand and there is not an ace in the hand, or else there is an ace in the hand and there is not a king in the hand.</p> <p><pre><code>p1 = View.from_str(\n    \"{~King()Ace(),King()~Ace()}\"\n)\n</code></pre> P2 There is a king in the hand. <pre><code>p2 = View.from_str(\"{King()}\")\n</code></pre></p>"},{"location":"usage/first_steps/#step-3-check-result","title":"Step 3: Check result","text":"<pre><code>c = default_inference_procedure((p1, p2))\nprint(c) #\"{~Ace()}\"\n</code></pre>"},{"location":"usage/first_steps/#full-example","title":"Full Example","text":"<pre><code>from pyetr import View\nfrom pyetr.inference import default_inference_procedure\n\np1 = View.from_str(\n    \"{~King()Ace(),King()~Ace()}\"\n)\np2 = View.from_str(\"{King()}\")\nc = default_inference_procedure((p1, p2))\nprint(c) #\"{~Ace()}\"\n</code></pre>"},{"location":"usage/pre_defined_cases/","title":"Exploring the pre-defined cases","text":"<p>All of the examples from the book \"Reason and Inquiry\" are available as part of the PyETR package. Below is shown an example detailing how to extract one of these from the package. This lets you get started with views without having to construct any yourself. If you would like to find another example, please see the case index. If would like to learn how to construct them yourself, please see here.</p> <p>Info</p> <p>All examples with the prefix \"new_\" are not found in the book, and test other operations that we considered during implementation of the package.</p> <p>Let's start off by inspecting one of the examples:</p> <p><pre><code>from pyetr.cases import e17\nprint(e17)\n</code></pre> Which outputs: <pre><code>description:\n    Example 17, p83\n\n    P1 There is a king in the hand and there is not an ace in the hand, or else there is an ace in the hand and there is not a king in the hand.\n    P2 There is a king in the hand.\n    C There isn't an ace in the hand.\n\nv (Views): (\n   {~King(k())Ace(a()),~Ace(a())King(k())},\n   {King(k())}\n)\nc (Conclusion): {~Ace(a())}\ntest(verbose=False): Method used to test the example\n</code></pre></p> <p>This starts off by describing the problem as it's presented in the book. It then shows in string form each of the views used in the problem, as well as the resulting conclusion. The test method runs the expected problem, and verifies that the output matches what is expected.</p> <p>By running the problem in verbose mode, we can see each of the steps involved:</p> <p><pre><code>e17.test(verbose=True)\n</code></pre> Which outputs: <pre><code>DeposeInput: {~King(k)Ace(a),~Ace(a)King(k)}^{0}\nDeposeOutput: {~King(k)Ace(a),~Ace(a)King(k)}^{0}\n\nUpdateInput: External: T Internal {~King(k)Ace(a),~Ace(a)King(k)}^{0}\nUniProdInput: External: T Internal {~Ace(a)King(k),~King(k)Ace(a)}^{0}\nUniProdOutput: T\nExiSumInput: External: T Internal {~Ace(a)King(k),~King(k)Ace(a)}^{0}\nExiSumOutput: T\nAnswerInput: External: T Internal {~Ace(a)King(k),~King(k)Ace(a)}^{0}\nEquilibriumAnswerInput: External: T Internal {~Ace(a)King(k),~King(k)Ace(a)}^{0}\nPotentials: [(0, 0)]\nEquilibriumAnswerOutput: T\nAtomicAnswerInput: External: T Internal {~Ace(a)King(k),~King(k)Ace(a)}^{0}\nAtomicAnswerOutput: T\nAnswerOutput: T\nMergeInput: External: T Internal {~Ace(a)King(k),~King(k)Ace(a)}^{0}\nMergeOutput: {~Ace(a)King(k),~King(k)Ace(a)}^{0}\nUpdateOutput: {~Ace(a)King(k),~King(k)Ace(a)}^{0}\n\n\nUpdateInput: External: {~Ace(a)King(k),~King(k)Ace(a)}^{0} Internal {King(k)}^{0}\nUniProdInput: External: {~Ace(a)King(k),~King(k)Ace(a)}^{0} Internal {King(k)}^{0}\nUniProdOutput: {~Ace(a)King(k),~King(k)Ace(a)}^{0}\nExiSumInput: External: {~Ace(a)King(k),~King(k)Ace(a)}^{0} Internal {King(k)}^{0}\nExiSumOutput: {~Ace(a)King(k),~King(k)Ace(a)}^{0}\nAnswerInput: External: {~Ace(a)King(k),~King(k)Ace(a)}^{0} Internal {King(k)}^{0}\nEquilibriumAnswerInput: External: {~Ace(a)King(k),~King(k)Ace(a)}^{0} Internal {King(k)}^{0}\nPotentials: [(0, ~Ace(a)King(k)), (0, ~King(k)Ace(a))]\nEquilibriumAnswerOutput: {~Ace(a)King(k),~King(k)Ace(a)}^{0}\nAtomicAnswerInput: External: {~Ace(a)King(k),~King(k)Ace(a)}^{0} Internal {King(k)}^{0}\nAtomicAnswerOutput: {~Ace(a)King(k)}^{0}\nAnswerOutput: {~Ace(a)King(k)}^{0}\nMergeInput: External: {~Ace(a)King(k)}^{0} Internal {King(k)}^{0}\nMergeOutput: {~Ace(a)King(k)}^{0}\nUpdateOutput: {~Ace(a)King(k)}^{0}\n\nFactorInput: External: {~Ace(a)King(k)}^{0} Internal F\nContradiction factor\nFactorOutput: {~Ace(a)King(k)}^{0}\nDeposeInput: {~King(k)Ace(a),~Ace(a)King(k)}^{0}\nDeposeOutput: {~King(k)Ace(a),~Ace(a)King(k)}^{0}\nFactorInput: External: {~Ace(a)King(k)}^{0} Internal {~King(k)Ace(a),~Ace(a)King(k)}^{0}\nCentral case factor\nFactorOutput: {~Ace(a)King(k)}^{0}\nFactorInput: External: {~Ace(a)King(k)}^{0} Internal {King(k)}^{0}\nCentral case factor\nFactorOutput: {~Ace(a)}^{0}\n</code></pre></p> <p>We can also inspect the input and output views:</p> <pre><code>print(e17.v) # ({~King(k())Ace(a()),King(k())~Ace(a())}, {King(k())})\nprint(e17.c) # {~Ace(a())}\n</code></pre>"},{"location":"usage/pre_defined_cases/#example-broken-down","title":"Example Broken Down","text":""},{"location":"usage/pre_defined_cases/#the-default-inference-way","title":"The default inference way","text":"<p>So this example really shows to compactness of using the examples. As I broke this down into individual steps in First Steps, here I will simply present the example in full:</p> <pre><code>from pyetr.cases import e17\nfrom pyetr.inference import default_inference_procedure\n\nresult = default_inference_procedure(e17.v)\nassert result == e17.c\nprint(result)\nprint(e17.c)\n</code></pre>"},{"location":"usage/pre_defined_cases/#the-view-operation-way","title":"The view operation way","text":"<p>However, we could also have done this using each of the underlying operations. See here:</p> <pre><code>from pyetr.cases import e17\nfrom pyetr import View\n\n# Basic step\nfirst = View.get_verum().update(e17.v[0].depose())\nprint(first) # {King()~Ace(),~King()Ace()}\ng_prime = first.update(e17.v[1])\nprint(g_prime) # {King()~Ace()}\n\n# G prime ops\ng_prime = g_prime.factor(e17.v[0].depose())\nprint(g_prime) # {King()~Ace()}\nresult = g_prime.factor(e17.v[1])\n\nprint(result) # {~Ace()}\nassert result == e17.c\n</code></pre> <p>Some can be excluded as no ops:</p> <pre><code>from pyetr.cases import e17\n\n# Basic step\ng_prime = e17.v[0].update(e17.v[1])\nprint(g_prime) # {King()~Ace()}\n\n#G prime ops\nresult = g_prime.factor(e17.v[1])\n\nprint(result) # {~Ace()}\nassert result == e17.c\n</code></pre> <p>...and we can even break <code>update</code> down into its fundamental operations:</p> <p><pre><code>from pyetr.cases import e17\n\n# Basic step\ng_prime = e17.v[0].universal_product(e17.v[1])\nprint(g_prime) # {Ace()~King(),~Ace()King()}\ng_prime = g_prime.existential_sum(e17.v[1])\nprint(g_prime) # {Ace()~King(),~Ace()King()}\ng_prime = g_prime.answer(e17.v[1])\nprint(g_prime) # {King()~Ace()}\ng_prime = g_prime.merge(e17.v[1])\nprint(g_prime) # {King()~Ace()}\n\n#G prime ops\nresult = g_prime.factor(e17.v[1])\nprint(result) # {~Ace()}\nassert result == e17.c\n</code></pre> Again, let's remove the no ops:</p> <pre><code>from pyetr.cases import e17\n\n# Basic step\ng_prime = e17.v[0].answer(e17.v[1])\nprint(g_prime) # {King()~Ace()}\n\n# G prime ops\nresult = g_prime.factor(e17.v[1])\nprint(result) # {~Ace()}\nassert result == e17.c\n</code></pre> <p>So here we see that, for this example, the problem is reducible to only a couple of much simpler operations. A useful property of PyETR is that problems can be expressed using very general functions, or at a very granular level depending on the exact nature of the problem.</p>"},{"location":"usage/view_construction/","title":"View construction","text":"<p>This page is a comprehensive guide to building your own views via the <code>View.from_str()</code> method. It will also serve to make more precise the anatomy of a view summarized earlier.</p> <p>The <code>View.from_str()</code> is the basic way that views are created in the case studies and how we expect most users will input their own views. The syntax required broadly follows the notation used in Reason &amp; Inquiry. The same syntax is the default format for printing views (the other formats were mentioned in the overview). You can explicitly convert to this string format with <code>.to_str()</code>.</p> <p>Info</p> <p>Since views are completely determined by the string representation, the following boolean test should always return <code>True</code> for any view <code>v</code>. <pre><code>v == View.from_str(v.to_str())\n</code></pre> See here for details about equality. However, you should not expect <pre><code>View.from_str(\"...\").to_str()\n</code></pre> to return an equal string. One reason is because printing to a string requires us to impose a linear order on the unordered components of a view. Another reason is that there are multiple ways to notate some features. Typically, where there is a 'pretty' notation used for printing that is less convenient to type, an alternative notation is provided. For example, <code>\u2200</code> is used in printing but for convenience <code>A</code> can be typed instead, see Dependency relations.</p> <p>For convenience, you only need to include in the string those parts of the view that are non-trivial or have non-default values. This helps when using PyETR for the earlier systems of R&amp;I, even though PyETR implements the full Chapter 6 system, as you will never have views cluttered with default values for the irrelevant components. There are a few notational caveats which will become apparent below (also summarized in Differences with R&amp;I).</p>"},{"location":"usage/view_construction/#basic-example","title":"Basic example","text":"<p>As an example, consider running the following code. This code might also be useful as a template for testing out features detailed below. <pre><code>from pyetr import View\n\np1 = View.from_str(\"{GrassWet()}\")\nprint(\"The view is \" + p1.to_str())\nprint(\"Slightly elaborated: \" + p1.base)\nprint(\"\\nIn detail:\")\nprint(p1.detailed)\nprint(\"\\nNB 'to_str()' is implicit if we print a view by itself:\")\nprint(p1)\n</code></pre> The output should be <pre><code>The view is {GrassWet()}\nSlightly elaborated: {GrassWet()}^{0}\n\nIn detail:\n&lt;View\n  stage={{&lt;PredicateAtom predicate=&lt;Predicate name=GrassWet arity=0&gt; terms=()&gt;}}\n  supposition={{}}\n  dep_rel=&lt;DependencyRelation deps=[] unis=frozenset() exis=frozenset()&gt;\n  issue_structure={}\n  weights=&lt;Weights {&lt;PredicateAtom predicate=&lt;Predicate name=GrassWet arity=0&gt; terms=()&gt;}: &lt;Weight multi=&lt;Multiset items=[]&gt; add=&lt;Multiset items=[]&gt;&gt;&gt;\n&gt;\n\nNB 'to_str()' is implicit if we print a view by itself:\n{GrassWet()}\n</code></pre> Observe that the basic method for creating a view from a string representation is the <code>from_str</code> method of the <code>View</code> class. To turn a view object into a string, use <code>to_str</code> of that view object.</p> <p>This string representation completely determines the view object, but for troubleshooting and debugging each view has a <code>detailed</code> property which explicitly states the entire contents. We can see in the above that while <code>p1.to_str()</code> only presents the <code>stage</code> of <code>p1</code>, in fact <code>p1</code> has a supposition (with default value <code>{{}}</code>) as well as a dependency relation, issue structure, and a collection of weights (all empty by default). The <code>base</code> property is provided in case it is useful for troubleshooting and also for its slightly closer connection with the notation used in R&amp;I.</p> <p>Unless specified otherwise, we'll be using the <code>to_str()</code> representation as the default.</p>"},{"location":"usage/view_construction/#stages-and-states","title":"Stages and states","text":"<p>Let us break down the following representation of view found in Example 8. <pre><code>{k()t(),a()q()}\n</code></pre></p> <p>At the core of any view is a set of states. In Reason &amp; Inquiry, this is the element of a view typically denoted by \u0393 (upper-case gamma). In the code base for PyETR, this is called the <code>stage</code>. A string representing a view must specify a stage between <code>{</code> and <code>}</code> as a comma-separated list of states. Thus in the example above, the view specifies a stage with two states: <code>k()t()</code> and <code>a()q()</code>.</p> <p>A state is a set of atoms. It is specified in PyETR as a list of atoms without any delimiters. Thus the two states in the example each consist of two atoms, one has <code>k()</code> and <code>t()</code> and the other has <code>a()</code> and <code>q()</code>. We will describe atoms below, but for now note that all atoms in PyETR consist of a string of ordinary characters followed by (possibly empty) matching parentheses. Thus the parsing of a string representing a state into a list of strings representing atoms is unambiguous, despite the lack of delimiters.</p> <p>Info</p> <p>The empty state is written <code>0</code>.</p>"},{"location":"usage/view_construction/#negation","title":"Negation","text":"<p>An atom is made negative by prepending a tilde <code>~</code> to it. This corresponds to the notation in Reason &amp; Inquiry where the negative counterpart of a positive atom was denoted by the same letter with an overline.</p> <p>For example, consider Example 22. Starting with the view denoted <pre><code>{a()c()b()}\n</code></pre> which has a single state containing the three atoms <code>a()</code>, <code>b()</code>, and <code>c()</code>, its negation is computed to be the view denoted <pre><code>{~c(),~b(),~a()}\n</code></pre> which has three states, each containing a singleton negative atom.</p>"},{"location":"usage/view_construction/#suppositions","title":"Suppositions","text":"<p>Suppositions are optional and are denoted with a <code>^</code> after the stage, using the same syntax for a set of states as for stages. In Reason &amp; Inquiry, suppositions were typically denoted by \u0398 (upper-case theta) and placed in superscript position following the stage.</p> <p>For example, consider Example 28. There is a view denoted <pre><code>{Tiger()Orange()}^{Tiger()}\n</code></pre> Here, the stage is <code>{Tiger()Orange()}</code> consisting of one state with two atoms (<code>Tiger()</code> and <code>Orange()</code>). The supposition is <code>{Tiger()}</code>, which consists of one state with one atom (just <code>Tiger()</code>).</p> <p>Info</p> <p>Omitting the supposition is equivalent to a supposition of <code>{0}</code>. That is, unless otherwise specified, a view has as its supposition the singleton set consisting of the empty state.</p>"},{"location":"usage/view_construction/#atoms","title":"Atoms","text":"<p>Atoms are formed by applying a predicate to a (possibly empty) list of terms. Consider this view from Example 50. <pre><code>{L(j(),s())L(s(),g())}\n</code></pre> This stage has a single state containing two atoms. For both atoms, <code>L</code> is read as a predicate applied to two terms, given as a comma-separated list inside the brackets following the name of the predicate. The <code>j()</code>, <code>s()</code>, and <code>g()</code> are examples of terms, we will see more examples as we continue.</p> <p>Atoms and terms can look similar. In the above, the parser infers that <code>j()</code> is a term rather than an atom because it appears inside the brackets associated to an atom. Any item at the top-level of a state must be an atom.</p> <p>Warning</p> <p><code>do</code> is a reserved name and should not be used for predicates. See Do atoms.</p>"},{"location":"usage/view_construction/#equality-atoms","title":"Equality Atoms","text":"<p>In Reason &amp; Inquiry, there is a privileged binary equality predicate which gets special treatment by some operations.</p> <p>We'll use one of the views from Example 88 to demonstrate: <pre><code>{==(Clark(), Superman())}\n</code></pre> The above statement is the same as \"Clark is superman\", we see the equates the ideas of Clark and Superman. It's defined in the usual way for a function, using <code>==</code> as the function name.</p>"},{"location":"usage/view_construction/#propositional-atoms","title":"Propositional Atoms","text":"<p>As in the example from Stages and states, in Reason &amp; Inquiry, the view from the example is written something like this: <pre><code>{kt, aq}\n</code></pre> For technical reasons we do not adopt this notation in PyETR. Thus, when working in the propositional fragment of ETR, it is necessary to insert the empty parentheses as a suffix to the name of atoms. This is mildly more cluttered than the notation used in Chapters 2 and 3 of Reason &amp; Inquiry, but, on the other hand, the presence of parentheses assists in using names for atoms that are longer than a single character.</p> <p>This is why examples such as Example 8 have extra parentheses in PyETR relative to Reason &amp; Inquiry.</p>"},{"location":"usage/view_construction/#terms","title":"Terms","text":"<p>A representation of a term takes one of three possible forms.</p>"},{"location":"usage/view_construction/#functional-terms","title":"Functional terms","text":"<p>This is a string of ordinary characters followed by parentheses containing a (possibly empty) comma-separated list of other term-representing strings.</p> <p>A function taking a empty list of arguments is essentially the same as a constant. Thus these functional terms are used to stand for the names of individuals, as in <code>Clark()</code> and <code>Superman()</code> above, as well as <code>j()</code>, <code>s()</code>, and <code>g()</code> ('John', 'Sally', and 'George').</p> <p>Compound terms where functions take one or more arguments most often appear in mathematical expressions. For example, in Example 93 the follow term appears, which is formed by applying the function <code>power</code> to a list of two other terms. <pre><code>power(\u03c3(1.0,log(\u03c3(1.0,x))),-1.0)\n</code></pre></p> <p>Warning</p> <p>In PyETR, there are a few reserved function names, see Special functions.</p> <p>Note for readers of Reason and Inquiry</p> <p>The behaviour of <code>\u03c3</code> mildly differs from Reason &amp; Inquiry, see Collapsing functions.</p>"},{"location":"usage/view_construction/#real-numbers","title":"Real numbers","text":"<p>Integers and decimals such as <code>1</code>, <code>1.0</code>, <code>-1.0</code>. These are constants (0 arity functional terms), but notably do not use the open-close bracket syntax. See here for details of how they interact with numeric functions.</p>"},{"location":"usage/view_construction/#arbitrary-objects","title":"Arbitrary objects","text":"<p>In PyETR, a string of ordinary characters not followed by parentheses is an arbitrary object. These can only appear if there is a suitable dependency relation.</p> <p>Warning</p> <p>Names can be reused between functional terms and arbitrary objects, e.g. <code>x()</code> and <code>x</code> are completely independent terms. Moreover, functions can appear several times with different arities, and are considered to be different functions (and thus form necessarily different terms).</p>"},{"location":"usage/view_construction/#issue-structures","title":"Issue structures","text":"<p>Issue structures are specified inserting asterisks immediately after a term which is at issue for its environment. This applies to terms appearing in states of the stage or supposition, (but not in weights) For example, in Example 47, the view <pre><code>{Thermotogum(Maritima()*)}\n</code></pre> has the (functional) term <code>Maritima()</code> at issue for the context <code>Thermotogum(?)</code>.</p> <p>Note for readers of Reason and Inquiry</p> <p>The issue structures in PyETR follow exactly the description given in Definition 4.7/A.29 in Reason &amp; Inquiry and the informal use of the circumflex in the book agrees with the asterisk here. For more information about issue structures we recommend taking a look at this.</p> <p>See Differences with R&amp;I, for a discussion on how Do atoms interact with issues.</p>"},{"location":"usage/view_construction/#issue-contexts","title":"Issue Contexts","text":"<p>For users unfamiliar with issue structures from R&amp;I, the following is a likely source of initial confusion. The following strings all represent the same view. <pre><code>{A(a()*),A(a())B(b())}\n{A(a()),A(a()*)B(b())}\n{A(a()*),A(a()*)B(b())}\n</code></pre> Converting any of them to string with <code>to_str()</code> will give the representation with two asterisks (i.e. the third one up to reordering).</p> <p>This is expected behaviour. The reason is that any of these asterisks informs PyETR that <code>a()</code> is at issue for the environment <code>A(?)</code>, and being at issue is a global property of the view not of the individual instances of <code>A(a())</code>. Thus it is not meaningful for some 'instances' of <code>A(a())</code> to have <code>a()</code> at issue and not others. When converting to string, all instances of <code>A(a())</code> are decorated with an asterisk as a canonical choice.</p> <p>This may be clearest if you print this in <code>v.base</code> mode like so: <pre><code>from pyetr import View\n\nprint(View.from_str(\"{A(a()*),A(a())B(b())}\").base) # {A(a),B(b)A(a)}^{0} issues={(a,A(?))}\nprint(View.from_str(\"{A(a()),A(a()*)B(b())}\").base) # {A(a),A(a)B(b)}^{0} issues={(a,A(?))}\nprint(View.from_str(\"{A(a()*),A(a()*)B(b())}\").base) # {A(a),A(a)B(b)}^{0} issues={(a,A(?))}\n</code></pre></p>"},{"location":"usage/view_construction/#dependency-relations","title":"Dependency relations","text":"<p>Dependency relations are specified by giving an equivalent string of quantifiers from first-order logic. For example, consider the following view from Example 56. <pre><code>\u2200z \u2203w {Student(z*)Reads(z,w)Book(w)}^{Student(z*)}\n</code></pre> Here, <code>z</code> and <code>w</code> are arbitrary objects. The prefix <code>\u2200z \u2203w</code> specifies that <code>z</code> is a universal arbitrary object and that <code>w</code> is an existential arbitrary object, and moreover that <code>w</code> has a dependence on <code>z</code>. Alternatively, a prefix of <code>\u2203w \u2200z</code> would import a lack of dependence of <code>w</code> on <code>z</code>.</p> <p>Warning</p> <p>The set of arbitrary objects that appear in the quantifier string must precisely match the set of arbitrary objects that appear in either the stage or supposition of the view. This is just as in Reason &amp; Inquiry. If it is not the case, an error will be raised.</p>"},{"location":"usage/view_construction/#alternative-syntax","title":"Alternative syntax","text":"<p>For convenience when typing, one can use <code>A</code> and <code>E</code> as synonyms for <code>\u2200</code> and <code>\u2203</code> respectively. So the above is equivalent to the following. <pre><code>Az Ew {Student(z*)Reads(z,w)Book(w)}^{Student(z*)}\n</code></pre></p>"},{"location":"usage/view_construction/#equality-of-dependency-relations","title":"Equality of dependency relations","text":"<p>The quantifier string corresponding to a dependency relation is unique up to reordering of within homogeneous quantifier blocks. Thus the following prints <code>True</code>. <pre><code>p1 = View.from_str(\"\u2200x \u2200y {A(x),B(y)}\")\np2 = View.from_str(\"\u2200y \u2200x {A(x),B(y)}\")\nprint(p1 == p2)\n</code></pre></p>"},{"location":"usage/view_construction/#weights","title":"Weights","text":"<p>Weights are an optional prefix to each state in the stage. For example, consider the following view appearing in Example 65. <pre><code>\u2200x {0.3=* P(x*)C(x),P(x*)~C(x)}^{P(x*)},\n</code></pre> This a view with two states where the state <code>P(x)C(x)</code> is assigned a multiplicative weight <code>0.3</code>.</p> <p>Each state has a multiplicative and an additive weight, introduced with <code>=*</code> and <code>=+</code> respectively. Both are optional. The <code>=*</code> should not be confused with the <code>*</code> for introducing items to the issue structure.</p> <p>Note for readers of Reason and Inquiry</p> <p>Note that the <code>base</code> representation of this view uses a notation for weights which is more familiar from R&amp;I. <pre><code>{\u27ea1.0,1.0,2.25\u27eb\u00d7.\u27ea7.0\u27eb+.A(),\u27ea1.0\u27eb+.B(),C()}^{0}\n</code></pre> PyETR implements the double-weighted states of Chapter 6 of Reason &amp; Inquiry. To work with the single-weighted states of Chapter 5, only use the multiplicative weight <code>=*</code> and leave the additive weight <code>=+</code> empty.</p> <p>Definition 5.4 of Reason &amp; Inquiry introduces a special binary function symbol for multiplication, used when combining two multiplicatively-weighted states. See XBar for how to input it, and see Collapsing functions.</p>"},{"location":"usage/view_construction/#multiset-weights","title":"Multiset Weights","text":"<p>Each weight is a multiset of terms, written as a list with the pipe <code>|</code> as delimiter. (A multiset is a set allowing repeated elements). For example, <pre><code>{ 1.0|1.0|2.25=* 7.0=+ A(), 1=+ B(), C() }\n</code></pre> represents a view where the state <code>A()</code> has for its multiplicative weight a multiset of size 3 and for its additive weight a multiset of size 1. The multiplicative weight of <code>B()</code>, and both weights of <code>C()</code>, are the empty multiset, the unique multiset of size 0. The example could also be written with explicit empty multisets as follows. <pre><code>{ 1.0|1.0|2.25=* 7.0=+ A(), =* 1=+ B(), =* =+ C() }\n</code></pre></p>"},{"location":"usage/view_construction/#ordering","title":"Ordering","text":"<p>Following the conventions of Reason &amp; Inquiry, the multiplicative weight is always given first. For example, <pre><code>{ 1.0=* 3.1=+ A()B() }\n</code></pre> is valid but <pre><code>{ 3.1=+ 1.0=* A()B() }\n</code></pre> will raise an error.</p>"},{"location":"usage/view_construction/#do-atoms","title":"Do atoms","text":"<p>Further to the predicate atoms discussed above at Atoms, do atoms are formed by using <code>do</code> like a predicate. For example, the following appears in Example 90. <pre><code>{do(Buy(Video()*)),~do(Buy(Video()))}\n</code></pre> The first state consists of a single atom, a positive do atom whose contents is <code>Buy(Video())</code>. Moreover, <code>Video()</code> is at issue for the matter of <code>do(Buy(?))</code>. The second state is a negative <code>do</code>-atom, simply the negation of the first. (Note that <code>Video()</code> is not at issue for <code>~do(Buy(?))</code>).</p> <p>The content of a do atom can be any state, even empty (denoted by empty brackets) For example, the following is a valid view. <pre><code>\u2200x { do(P(x)Q(x)R()), do(), do(P(x))do(Q(x)) }\n</code></pre></p> <p>Note for readers of Reason and Inquiry</p> <p>In Reason &amp; Inquiry, 'do' could not appear inside the contents of a do-atom. PyETR does not currently enforce this, but behaviour when nested <code>do</code>-atoms might be unpredictable.</p>"},{"location":"usage/view_construction/#numeric-functions","title":"Numeric Functions","text":"<p>There are are number of numeric functions available in PyETR. It's also possible to define your own custom functions, but for details of this please see the advanced section.</p> <p>Below are the details for each of the built-in numeric functions, that each have their own syntaxes for view construction.</p>"},{"location":"usage/view_construction/#xbar","title":"Xbar","text":"<p>Xbar is numeric multiplication, receiving 2 arguments. There are a couple of different ways to express this function. It may be represented using <code>**</code> or <code>x\u0304</code>; for the purposes of demonstration we'll use <code>**</code>.</p> <p>As demonstrated in Example 74, it can be used to simply represent a numeric multiplication like so:</p> <p><pre><code>{A(4**5)} # Resolving to {A(20.0)}\n</code></pre> If preferred it can also be written using the prefix notation: <pre><code>{A(**(4,5))} # Resolving to {A(20.0)}\n</code></pre></p> <p>It is also used in the Non-Book example New Example 18:</p> <pre><code>{m()=* A()}\n{n()=* B()}\n\n# And the result after an update operation:\n{m() ** n()=* A() B()}\n</code></pre> <p>Here we see that multiplication can also result from internal operations.</p>"},{"location":"usage/view_construction/#summation","title":"Summation","text":"<p>Summation is numeric summation, receiving a Multiset of arguments. It may be represented using <code>++</code> or <code>\u03c3</code>; for the purposes of demonstration we'll use <code>++</code>.</p> <p>This is used internally, and in part of Example 93.</p> <pre><code>Ax {++(1, log(++(1, x)))=+ 0} ^ {S(x*)}\n</code></pre> <p>Here this is used to represent the term: \\(1+\\log(1+x)\\)</p> <p>The summation may contain zero or more arguments.</p>"},{"location":"usage/view_construction/#sample-functions","title":"Sample functions","text":"<p>Sample functions can be imported from the func_library namespace. These represent some simple example numeric functions - below is a short example detailing usage with the div function:</p> <pre><code>from pyetr import View\nfrom pyetr.func_library import div\n\n\nprint(View.from_str(\"{A(div(100,3))}\", custom_functions=[div]))\n</code></pre>"},{"location":"usage/view_construction/#div","title":"<code>div</code>","text":"<p>A function representing divide (takes 2 arguments, numerator and denominator)</p>"},{"location":"usage/view_construction/#power","title":"<code>power</code>","text":"<p>A function representing power (takes 2 arguments, base and power)</p>"},{"location":"usage/view_construction/#log","title":"<code>log</code>","text":"<p>A function representing log base 10 (takes 1 argument)</p>"},{"location":"usage/view_methods_example/","title":"View methods example","text":"<p>First let's take two views:</p> <ul> <li> <p>View 1: {t()=+ A()}</p> </li> <li> <p>View 2: {u()=* A()}</p> </li> </ul> <p>Suppose we would like to update View 1 with View 2. First we create Views from each string:</p> <pre><code>from pyetr import View\n\nview1 = View.from_str(\"{t()=+ A()}\")\nview2 = View.from_str(\"{u()=* A()}\")\n</code></pre> <p>Now we can use the update method from view1 to update with view2:</p> <pre><code>updated_view = view1.update(view2)\nprint(updated_view.to_str()) # {u()=* t()=+ A()}\n</code></pre>"},{"location":"usage/view_methods_example/#full-example","title":"Full example","text":"<pre><code>from pyetr import View\n\nview1 = View.from_str(\"{t()=+ A()}\")\nview2 = View.from_str(\"{u()=* A()}\")\n\nupdated_view = view1.update(view2)\nprint(updated_view.to_str()) # {u()=* t()=+ A()}\n</code></pre>"}]}